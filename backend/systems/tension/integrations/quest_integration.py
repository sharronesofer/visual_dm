"""
Tension-Quest System Integration

Dynamically generates and modifies quests based on tension levels:
- High-tension areas spawn conflict resolution quests
- Tension events create urgent rescue/defense missions
- Regional conflicts generate faction-related quests
- Peace restoration quests in post-conflict areas
- Investigation quests for tension sources

This follows the integration patterns from the quest system.
"""

import logging
from typing import Dict, Any, List, Optional
from enum import Enum
from datetime import datetime

from backend.systems.tension import UnifiedTensionManager
from backend.infrastructure.events import event_bus

logger = logging.getLogger(__name__)


class TensionQuestType(Enum):
    """Types of quests generated by tension events"""
    CONFLICT_RESOLUTION = "conflict_resolution"
    EMERGENCY_RESCUE = "emergency_rescue" 
    FACTION_MEDIATION = "faction_mediation"
    PEACE_RESTORATION = "peace_restoration"
    TENSION_INVESTIGATION = "tension_investigation"
    REFUGEE_AID = "refugee_aid"
    SECURITY_PATROL = "security_patrol"
    DIPLOMATIC_MISSION = "diplomatic_mission"


class TensionQuestIntegration:
    """Integrates tension system with quest generation"""
    
    def __init__(self, tension_manager: Optional[UnifiedTensionManager] = None):
        self.tension_manager = tension_manager or UnifiedTensionManager()
        self.generated_quests_cache: Dict[str, List[str]] = {}  # region -> quest_ids
        self.quest_generation_cooldowns: Dict[str, datetime] = {}
        
        # Register for tension events
        self._register_event_handlers()
    
    def _register_event_handlers(self) -> None:
        """Register event handlers for tension changes"""
        event_bus.subscribe("tension:level_changed", self._handle_tension_change)
        event_bus.subscribe("tension:conflict_triggered", self._handle_conflict_triggered)
        event_bus.subscribe("tension:conflict_resolved", self._handle_conflict_resolved)
        event_bus.subscribe("quest:completed", self._handle_quest_completed)
    
    async def _handle_tension_change(self, event_data: Dict[str, Any]) -> None:
        """Handle tension level changes that might generate quests"""
        region_id = event_data.get('region_id')
        poi_id = event_data.get('poi_id')
        new_tension = event_data.get('tension_level', 0.0)
        old_tension = event_data.get('previous_tension', 0.0)
        
        if region_id and poi_id:
            await self.evaluate_quest_generation(region_id, poi_id, new_tension, old_tension)
    
    async def _handle_conflict_triggered(self, event_data: Dict[str, Any]) -> None:
        """Handle conflict events that should generate urgent quests"""
        region_id = event_data.get('region_id')
        conflict_type = event_data.get('conflict_type', 'unknown')
        severity = event_data.get('severity', 1.0)
        
        if region_id:
            await self.generate_conflict_quests(region_id, conflict_type, severity)
    
    async def _handle_conflict_resolved(self, event_data: Dict[str, Any]) -> None:
        """Handle conflict resolution that might generate restoration quests"""
        region_id = event_data.get('region_id')
        resolution_type = event_data.get('resolution_type', 'peaceful')
        
        if region_id:
            await self.generate_post_conflict_quests(region_id, resolution_type)
    
    async def _handle_quest_completed(self, event_data: Dict[str, Any]) -> None:
        """Handle quest completion that might affect tension"""
        quest_id = event_data.get('quest_id')
        quest_type = event_data.get('quest_type')
        region_id = event_data.get('region_id')
        
        if quest_type in [qt.value for qt in TensionQuestType] and region_id:
            await self.apply_quest_completion_effects(quest_id, quest_type, region_id)
    
    async def evaluate_quest_generation(self, region_id: str, poi_id: str, 
                                      new_tension: float, old_tension: float) -> None:
        """Evaluate whether to generate quests based on tension changes"""
        try:
            location_key = f"{region_id}:{poi_id}"
            
            # Check cooldown
            if self._is_quest_generation_on_cooldown(location_key):
                return
            
            # High tension crossing threshold
            if new_tension >= 0.7 and old_tension < 0.7:
                await self._generate_high_tension_quests(region_id, poi_id, new_tension)
            
            # Sudden tension spike (>0.3 increase)
            elif new_tension - old_tension > 0.3:
                await self._generate_tension_spike_quests(region_id, poi_id, new_tension)
            
            # Gradual tension resolution
            elif old_tension >= 0.5 and new_tension < 0.3:
                await self._generate_peace_restoration_quests(region_id, poi_id)
            
        except Exception as e:
            logger.error(f"Error evaluating quest generation: {e}")
    
    async def _generate_high_tension_quests(self, region_id: str, poi_id: str, tension_level: float) -> None:
        """Generate quests for high-tension situations"""
        quest_templates = []
        
        if tension_level >= 0.9:  # Critical tension
            quest_templates.extend([
                {
                    'type': TensionQuestType.EMERGENCY_RESCUE.value,
                    'title': f'Emergency Evacuation - {poi_id}',
                    'description': f'Critical situation in {poi_id}. Civilians need immediate evacuation.',
                    'urgency': 'critical',
                    'reward_multiplier': 2.0
                },
                {
                    'type': TensionQuestType.SECURITY_PATROL.value,
                    'title': f'Restore Order in {poi_id}',
                    'description': f'Violence has erupted in {poi_id}. Restore peace and security.',
                    'urgency': 'high',
                    'reward_multiplier': 1.8
                }
            ])
        
        elif tension_level >= 0.7:  # High tension
            quest_templates.extend([
                {
                    'type': TensionQuestType.CONFLICT_RESOLUTION.value,
                    'title': f'Mediate Conflict in {poi_id}',
                    'description': f'Growing tensions in {poi_id} threaten to boil over. Find a peaceful solution.',
                    'urgency': 'medium',
                    'reward_multiplier': 1.5
                },
                {
                    'type': TensionQuestType.TENSION_INVESTIGATION.value,
                    'title': f'Investigate Unrest in {poi_id}',
                    'description': f'Discover the root cause of growing tensions in {poi_id}.',
                    'urgency': 'medium',
                    'reward_multiplier': 1.3
                }
            ])
        
        await self._submit_quest_generation(region_id, poi_id, quest_templates)
    
    async def _generate_tension_spike_quests(self, region_id: str, poi_id: str, tension_level: float) -> None:
        """Generate quests for sudden tension increases"""
        quest_templates = [
            {
                'type': TensionQuestType.TENSION_INVESTIGATION.value,
                'title': f'Investigate Sudden Unrest - {poi_id}',
                'description': f'Something has dramatically escalated tensions in {poi_id}. Find out what happened.',
                'urgency': 'high',
                'reward_multiplier': 1.4,
                'objectives': [
                    'Interview local witnesses',
                    'Examine the scene for clues',
                    'Identify the catalyst event'
                ]
            }
        ]
        
        if tension_level >= 0.8:
            quest_templates.append({
                'type': TensionQuestType.EMERGENCY_RESCUE.value,
                'title': f'Immediate Response - {poi_id}',
                'description': f'Rapid escalation in {poi_id} requires immediate intervention.',
                'urgency': 'critical',
                'reward_multiplier': 1.8
            })
        
        await self._submit_quest_generation(region_id, poi_id, quest_templates)
    
    async def _generate_peace_restoration_quests(self, region_id: str, poi_id: str) -> None:
        """Generate quests for post-conflict restoration"""
        quest_templates = [
            {
                'type': TensionQuestType.PEACE_RESTORATION.value,
                'title': f'Rebuild Trust in {poi_id}',
                'description': f'Help {poi_id} recover from recent conflicts and rebuild community trust.',
                'urgency': 'low',
                'reward_multiplier': 1.2,
                'objectives': [
                    'Organize community meetings',
                    'Facilitate reconciliation talks',
                    'Establish new cooperation agreements'
                ]
            },
            {
                'type': TensionQuestType.REFUGEE_AID.value,
                'title': f'Aid Displaced Residents - {poi_id}',
                'description': f'Help those displaced by the recent conflict in {poi_id}.',
                'urgency': 'medium',
                'reward_multiplier': 1.0
            }
        ]
        
        await self._submit_quest_generation(region_id, poi_id, quest_templates)
    
    async def generate_conflict_quests(self, region_id: str, conflict_type: str, severity: float) -> None:
        """Generate quests specific to conflict events"""
        try:
            quest_templates = []
            
            if conflict_type == 'faction_warfare':
                quest_templates.extend([
                    {
                        'type': TensionQuestType.FACTION_MEDIATION.value,
                        'title': f'Mediate Faction Dispute - {region_id}',
                        'description': f'Warring factions in {region_id} need outside mediation.',
                        'urgency': 'high',
                        'reward_multiplier': severity,
                        'faction_related': True
                    },
                    {
                        'type': TensionQuestType.DIPLOMATIC_MISSION.value,
                        'title': f'Diplomatic Intervention - {region_id}',
                        'description': f'Attempt to negotiate a ceasefire between warring factions.',
                        'urgency': 'critical',
                        'reward_multiplier': severity * 1.5
                    }
                ])
            
            elif conflict_type == 'civil_unrest':
                quest_templates.extend([
                    {
                        'type': TensionQuestType.SECURITY_PATROL.value,
                        'title': f'Restore Order - {region_id}',
                        'description': f'Civil unrest has broken out in {region_id}. Restore peace.',
                        'urgency': 'high',
                        'reward_multiplier': severity * 1.2
                    },
                    {
                        'type': TensionQuestType.CONFLICT_RESOLUTION.value,
                        'title': f'Address Grievances - {region_id}',
                        'description': f'Identify and address the root causes of unrest in {region_id}.',
                        'urgency': 'medium',
                        'reward_multiplier': severity
                    }
                ])
            
            elif conflict_type == 'external_threat':
                quest_templates.extend([
                    {
                        'type': TensionQuestType.SECURITY_PATROL.value,
                        'title': f'Defend {region_id}',
                        'description': f'External forces threaten {region_id}. Organize defenses.',
                        'urgency': 'critical',
                        'reward_multiplier': severity * 2.0
                    },
                    {
                        'type': TensionQuestType.EMERGENCY_RESCUE.value,
                        'title': f'Evacuate Civilians - {region_id}',
                        'description': f'Get civilians to safety as external threats approach {region_id}.',
                        'urgency': 'critical',
                        'reward_multiplier': severity * 1.5
                    }
                ])
            
            await self._submit_quest_generation(region_id, 'region_wide', quest_templates)
            
        except Exception as e:
            logger.error(f"Error generating conflict quests: {e}")
    
    async def generate_post_conflict_quests(self, region_id: str, resolution_type: str) -> None:
        """Generate restoration quests after conflict resolution"""
        try:
            quest_templates = []
            
            if resolution_type == 'peaceful':
                quest_templates.extend([
                    {
                        'type': TensionQuestType.PEACE_RESTORATION.value,
                        'title': f'Consolidate Peace - {region_id}',
                        'description': f'Help ensure the peaceful resolution in {region_id} holds.',
                        'urgency': 'medium',
                        'reward_multiplier': 1.3
                    },
                    {
                        'type': TensionQuestType.DIPLOMATIC_MISSION.value,
                        'title': f'Strengthen Agreements - {region_id}',
                        'description': f'Help formalize and strengthen peace agreements in {region_id}.',
                        'urgency': 'low',
                        'reward_multiplier': 1.1
                    }
                ])
            
            elif resolution_type == 'victory':
                quest_templates.extend([
                    {
                        'type': TensionQuestType.PEACE_RESTORATION.value,
                        'title': f'Reconcile Factions - {region_id}',
                        'description': f'Help the defeated faction reintegrate peacefully in {region_id}.',
                        'urgency': 'medium',
                        'reward_multiplier': 1.2
                    },
                    {
                        'type': TensionQuestType.REFUGEE_AID.value,
                        'title': f'Aid War Victims - {region_id}',
                        'description': f'Provide assistance to those affected by the conflict in {region_id}.',
                        'urgency': 'medium',
                        'reward_multiplier': 1.1
                    }
                ])
            
            await self._submit_quest_generation(region_id, 'post_conflict', quest_templates)
            
        except Exception as e:
            logger.error(f"Error generating post-conflict quests: {e}")
    
    async def apply_quest_completion_effects(self, quest_id: str, quest_type: str, region_id: str) -> None:
        """Apply tension effects when tension-related quests are completed"""
        try:
            # Quest completion affects tension based on quest type
            tension_effects = {
                TensionQuestType.CONFLICT_RESOLUTION.value: -0.2,
                TensionQuestType.EMERGENCY_RESCUE.value: -0.1,
                TensionQuestType.FACTION_MEDIATION.value: -0.25,
                TensionQuestType.PEACE_RESTORATION.value: -0.15,
                TensionQuestType.TENSION_INVESTIGATION.value: -0.05,
                TensionQuestType.REFUGEE_AID.value: -0.1,
                TensionQuestType.SECURITY_PATROL.value: -0.15,
                TensionQuestType.DIPLOMATIC_MISSION.value: -0.3
            }
            
            tension_reduction = tension_effects.get(quest_type, 0.0)
            
            if tension_reduction != 0.0:
                # Apply tension reduction to the region
                await self._apply_tension_modifier(region_id, tension_reduction, f"quest_completion_{quest_type}")
                
                logger.info(f"Quest {quest_id} completion reduced tension by {abs(tension_reduction)} in {region_id}")
            
        except Exception as e:
            logger.error(f"Error applying quest completion effects: {e}")
    
    async def _submit_quest_generation(self, region_id: str, poi_id: str, quest_templates: List[Dict[str, Any]]) -> None:
        """Submit quest templates to the quest system for generation"""
        try:
            for template in quest_templates:
                # Add tension-specific metadata
                template.update({
                    'source': 'tension_system',
                    'region_id': region_id,
                    'poi_id': poi_id,
                    'generated_at': datetime.utcnow().isoformat(),
                    'tension_related': True
                })
            
            # Emit quest generation event
            event_bus.emit("quest:generate_from_tension", {
                'region_id': region_id,
                'poi_id': poi_id,
                'quest_templates': quest_templates,
                'generator': 'tension_system'
            })
            
            # Update cache and cooldown
            location_key = f"{region_id}:{poi_id}"
            if location_key not in self.generated_quests_cache:
                self.generated_quests_cache[location_key] = []
            
            self.quest_generation_cooldowns[location_key] = datetime.utcnow()
            
            logger.info(f"Generated {len(quest_templates)} tension-based quests for {location_key}")
            
        except Exception as e:
            logger.error(f"Error submitting quest generation: {e}")
    
    async def _apply_tension_modifier(self, region_id: str, tension_change: float, source: str) -> None:
        """Apply tension modifier to a region"""
        try:
            # This would integrate with the tension manager to apply regional effects
            event_bus.emit("tension:apply_regional_modifier", {
                'region_id': region_id,
                'tension_change': tension_change,
                'source': source,
                'duration_hours': 24.0  # Quest effects last 24 hours
            })
            
        except Exception as e:
            logger.error(f"Error applying tension modifier: {e}")
    
    def _is_quest_generation_on_cooldown(self, location_key: str, cooldown_minutes: int = 30) -> bool:
        """Check if quest generation is on cooldown for a location"""
        if location_key not in self.quest_generation_cooldowns:
            return False
        
        last_generation = self.quest_generation_cooldowns[location_key]
        time_since = datetime.utcnow() - last_generation
        
        return time_since.total_seconds() < (cooldown_minutes * 60)
    
    def get_tension_quest_suggestions(self, region_id: str, player_level: int = 1) -> List[Dict[str, Any]]:
        """Get quest suggestions based on current tension levels in a region"""
        try:
            suggestions = []
            
            # Get all POIs in region with high tension
            # This would integrate with region/POI systems
            high_tension_pois = self._get_high_tension_pois(region_id)
            
            for poi_id, tension_level in high_tension_pois.items():
                if tension_level >= 0.7:
                    suggestions.append({
                        'poi_id': poi_id,
                        'tension_level': tension_level,
                        'suggested_quest_types': [
                            TensionQuestType.CONFLICT_RESOLUTION.value,
                            TensionQuestType.SECURITY_PATROL.value
                        ],
                        'urgency': 'high' if tension_level >= 0.8 else 'medium',
                        'recommended_level': max(player_level, int(tension_level * 10))
                    })
                
                elif tension_level >= 0.4:
                    suggestions.append({
                        'poi_id': poi_id,
                        'tension_level': tension_level,
                        'suggested_quest_types': [
                            TensionQuestType.TENSION_INVESTIGATION.value,
                            TensionQuestType.PEACE_RESTORATION.value
                        ],
                        'urgency': 'medium',
                        'recommended_level': max(player_level, int(tension_level * 8))
                    })
            
            return suggestions
            
        except Exception as e:
            logger.error(f"Error getting tension quest suggestions: {e}")
            return []
    
    def _get_high_tension_pois(self, region_id: str) -> Dict[str, float]:
        """Get POIs in region with tension levels above threshold"""
        # This would integrate with the actual tension and region systems
        # For now, returning placeholder data
        return {
            'tavern': 0.75,
            'market': 0.45,
            'guard_post': 0.85
        }
    
    def get_integration_status(self) -> Dict[str, Any]:
        """Get status of tension-quest integration"""
        return {
            'generated_quests_by_region': {k: len(v) for k, v in self.generated_quests_cache.items()},
            'active_cooldowns': len(self.quest_generation_cooldowns),
            'quest_types': [qt.value for qt in TensionQuestType],
            'integration_active': True
        } 