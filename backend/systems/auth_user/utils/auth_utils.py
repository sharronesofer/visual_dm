"""
Authentication relationship utilities to manage connections between users and characters.

This module implements the character-user auth relationship functionality described in the
Development Bible's Character Relationship System (Canonical).
"""

from typing import List, Dict, Optional, Any, Union, Set
from uuid import UUID

# Type aliases
UserId = Union[str, UUID]
CharacterId = Union[str, UUID]
EntityId = Union[str, UUID]  # Generic ID type that can be used for either users or characters

async def create_auth_relationship(
    source_id: UserId,
    target_id: CharacterId,
    permissions: List[str] = None,
    is_owner: bool = False
) -> Dict[str, Any]:
    """
    Create an authentication relationship between a user and a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        permissions: List of permission strings (default: empty list)
        is_owner: Whether the user is the owner of the character (default: False)
        
    Returns:
        The created relationship as a dictionary
    """
    if permissions is None:
        permissions = []
    
    # TODO: Implement actual database interaction
    # This is a placeholder that would be replaced with actual DB operations
    relationship = {
        "source_id": str(source_id),
        "target_id": str(target_id),
        "type": "auth",
        "data": {
            "permissions": permissions,
            "owner": is_owner
        },
        "created_at": "2023-08-01T00:00:00Z",  # Would be auto-generated by DB
        "updated_at": "2023-08-01T00:00:00Z"   # Would be auto-generated by DB
    }
    
    # In actual implementation, you would save this to DB and return the result
    return relationship

async def update_auth_relationship(
    source_id: UserId,
    target_id: CharacterId,
    permissions: Optional[List[str]] = None,
    is_owner: Optional[bool] = None
) -> Dict[str, Any]:
    """
    Update an existing authentication relationship between a user and a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        permissions: New list of permission strings (if None, not updated)
        is_owner: New owner status (if None, not updated)
        
    Returns:
        The updated relationship as a dictionary
        
    Raises:
        ValueError: If the relationship doesn't exist
    """
    # TODO: Implement actual database interaction
    # First we would fetch the existing relationship
    # This is just a placeholder
    existing = {
        "source_id": str(source_id),
        "target_id": str(target_id),
        "type": "auth",
        "data": {
            "permissions": ["play"],
            "owner": False
        }
    }
    
    # Update the fields that were provided
    if permissions is not None:
        existing["data"]["permissions"] = permissions
    if is_owner is not None:
        existing["data"]["owner"] = is_owner
    
    # In actual implementation, you would save this back to DB
    return existing

async def remove_auth_relationship(
    source_id: UserId,
    target_id: CharacterId
) -> bool:
    """
    Remove an authentication relationship between a user and a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        
    Returns:
        True if successful, False if not found
    """
    # TODO: Implement actual database operation to delete the relationship
    # This is just a placeholder returning success
    return True

async def get_auth_relationship(
    source_id: UserId,
    target_id: CharacterId
) -> Optional[Dict[str, Any]]:
    """
    Get an authentication relationship between a user and a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        
    Returns:
        The relationship as a dictionary, or None if not found
    """
    # TODO: Implement actual database query
    # This is just a placeholder
    relationship = {
        "source_id": str(source_id),
        "target_id": str(target_id),
        "type": "auth",
        "data": {
            "permissions": ["play", "edit"],
            "owner": True
        }
    }
    return relationship

async def check_permission(
    source_id: UserId,
    target_id: CharacterId,
    permission: str
) -> bool:
    """
    Check if a user has a specific permission for a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        permission: The permission to check
        
    Returns:
        True if the user has the permission, False otherwise
    """
    relationship = await get_auth_relationship(source_id, target_id)
    if relationship is None:
        return False
    
    # Owners have all permissions
    if relationship["data"].get("owner", False):
        return True
    
    return permission in relationship["data"].get("permissions", [])

async def add_permission(
    source_id: UserId,
    target_id: CharacterId,
    permission: str
) -> Dict[str, Any]:
    """
    Add a permission to a user's relationship with a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        permission: The permission to add
        
    Returns:
        The updated relationship
    """
    relationship = await get_auth_relationship(source_id, target_id)
    if relationship is None:
        # If no relationship exists, create a new one with this permission
        return await create_auth_relationship(source_id, target_id, permissions=[permission])
    
    permissions = relationship["data"].get("permissions", [])
    if permission not in permissions:
        permissions.append(permission)
        return await update_auth_relationship(source_id, target_id, permissions=permissions)
    
    return relationship

async def remove_permission(
    source_id: UserId,
    target_id: CharacterId,
    permission: str
) -> Dict[str, Any]:
    """
    Remove a permission from a user's relationship with a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        permission: The permission to remove
        
    Returns:
        The updated relationship
    """
    relationship = await get_auth_relationship(source_id, target_id)
    if relationship is None:
        # Can't remove from non-existent relationship
        raise ValueError("Relationship does not exist")
    
    permissions = relationship["data"].get("permissions", [])
    if permission in permissions:
        permissions.remove(permission)
        return await update_auth_relationship(source_id, target_id, permissions=permissions)
    
    return relationship

async def set_ownership(
    source_id: UserId,
    target_id: CharacterId,
    is_owner: bool
) -> Dict[str, Any]:
    """
    Set or remove ownership status for a user's relationship with a character.
    
    Args:
        source_id: The ID of the user
        target_id: The ID of the character
        is_owner: Whether the user should be the owner
        
    Returns:
        The updated relationship
    """
    relationship = await get_auth_relationship(source_id, target_id)
    if relationship is None:
        # If no relationship exists, create a new one with this ownership status
        return await create_auth_relationship(source_id, target_id, is_owner=is_owner)
    
    return await update_auth_relationship(source_id, target_id, is_owner=is_owner)

async def get_user_characters(
    user_id: UserId,
    include_permissions: bool = False
) -> List[Dict[str, Any]]:
    """
    Get all characters that a user has access to.
    
    Args:
        user_id: The ID of the user
        include_permissions: Whether to include permission details in the response
        
    Returns:
        List of character data with relationship info
    """
    # TODO: Implement actual database query
    # This is just a placeholder
    # In a real implementation, you would:
    # 1. Query the relationships table for relationships with source_id = user_id and type = "auth"
    # 2. Query the character table for the corresponding target_ids
    # 3. Combine the data as needed
    
    # Placeholder response
    return [
        {
            "character_id": "1234abcd-1234-5678-abcd-1234567890ab",
            "name": "Character 1",
            "level": 5,
            "relationship": {
                "is_owner": True,
                "permissions": ["play", "edit"] if include_permissions else []
            }
        },
        {
            "character_id": "5678efgh-1234-5678-abcd-1234567890cd",
            "name": "Character 2",
            "level": 3,
            "relationship": {
                "is_owner": False,
                "permissions": ["play"] if include_permissions else []
            }
        }
    ]

async def get_character_users(
    character_id: CharacterId,
    include_permissions: bool = False
) -> List[Dict[str, Any]]:
    """
    Get all users that have access to a character.
    
    Args:
        character_id: The ID of the character
        include_permissions: Whether to include permission details in the response
        
    Returns:
        List of user data with relationship info
    """
    # TODO: Implement actual database query
    # This is just a placeholder
    # In a real implementation, you would:
    # 1. Query the relationships table for relationships with target_id = character_id and type = "auth"
    # 2. Query the user table for the corresponding source_ids
    # 3. Combine the data as needed
    
    # Placeholder response
    return [
        {
            "user_id": "abcd1234-1234-5678-abcd-1234567890ab",
            "email": "user1@example.com",
            "relationship": {
                "is_owner": True,
                "permissions": ["play", "edit"] if include_permissions else []
            }
        },
        {
            "user_id": "efgh5678-1234-5678-abcd-1234567890cd",
            "email": "user2@example.com",
            "relationship": {
                "is_owner": False,
                "permissions": ["play"] if include_permissions else []
            }
        }
    ]

async def bulk_create_auth_relationships(
    relationships: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Create multiple auth relationships in a single operation.
    
    Args:
        relationships: List of relationship data dictionaries, each containing:
                       - source_id: User ID
                       - target_id: Character ID
                       - permissions: List of permission strings (optional)
                       - is_owner: Whether the user is the owner (optional)
                       
    Returns:
        List of created relationships
    """
    results = []
    for relationship_data in relationships:
        source_id = relationship_data["source_id"]
        target_id = relationship_data["target_id"]
        permissions = relationship_data.get("permissions", [])
        is_owner = relationship_data.get("is_owner", False)
        
        result = await create_auth_relationship(
            source_id, target_id, permissions, is_owner
        )
        results.append(result)
    
    return results

async def bulk_remove_auth_relationships(
    relationships: List[Dict[str, Any]]
) -> List[bool]:
    """
    Remove multiple auth relationships in a single operation.
    
    Args:
        relationships: List of relationship data dictionaries, each containing:
                       - source_id: User ID
                       - target_id: Character ID
                       
    Returns:
        List of booleans indicating success for each relationship
    """
    results = []
    for relationship_data in relationships:
        source_id = relationship_data["source_id"]
        target_id = relationship_data["target_id"]
        
        result = await remove_auth_relationship(source_id, target_id)
        results.append(result)
    
    return results

async def transfer_character_ownership(
    character_id: CharacterId,
    from_user_id: UserId,
    to_user_id: UserId,
    keep_original_permissions: bool = True
) -> Dict[str, Any]:
    """
    Transfer ownership of a character from one user to another.
    
    Args:
        character_id: The ID of the character
        from_user_id: The ID of the current owner
        to_user_id: The ID of the new owner
        keep_original_permissions: Whether to keep the original owner's permissions
        
    Returns:
        The new owner's relationship with the character
        
    Raises:
        ValueError: If the original user is not the owner or relationship doesn't exist
    """
    # Check current ownership
    current_relationship = await get_auth_relationship(from_user_id, character_id)
    if current_relationship is None:
        raise ValueError("Original user has no relationship with this character")
        
    if not current_relationship["data"].get("owner", False):
        raise ValueError("Original user is not the owner of this character")
    
    # Get or create relationship for the new owner
    new_relationship = await get_auth_relationship(to_user_id, character_id)
    new_permissions = []
    
    # If new relationship exists, keep existing permissions
    if new_relationship is not None:
        new_permissions = new_relationship["data"].get("permissions", [])
    
    # Set ownership for new user
    new_relationship = await set_ownership(to_user_id, character_id, True)
    
    # Remove ownership from original user
    current_permissions = current_relationship["data"].get("permissions", [])
    
    if keep_original_permissions:
        # Keep permissions but remove ownership
        await update_auth_relationship(from_user_id, character_id, 
                                       permissions=current_permissions, 
                                       is_owner=False)
    else:
        # Remove the relationship entirely
        await remove_auth_relationship(from_user_id, character_id)
    
    return new_relationship

async def check_multi_character_permission(
    user_id: UserId,
    character_ids: List[CharacterId],
    permission: str,
    require_all: bool = True
) -> Dict[str, bool]:
    """
    Check if a user has a specific permission for multiple characters.
    
    Args:
        user_id: The ID of the user
        character_ids: List of character IDs to check
        permission: The permission to check
        require_all: If True, the user must have permission for all characters
                    If False, returns a mapping of character IDs to permission status
        
    Returns:
        If require_all is True: {"has_permission": bool}
        If require_all is False: {"has_permission": bool, "details": Dict[str, bool]}
    """
    results = {}
    for character_id in character_ids:
        has_permission = await check_permission(user_id, character_id, permission)
        results[str(character_id)] = has_permission
    
    if require_all:
        return {"has_permission": all(results.values())}
    else:
        return {
            "has_permission": any(results.values()),
            "details": results
        }

async def get_permission_matrix(
    user_ids: List[UserId],
    character_ids: List[CharacterId]
) -> Dict[str, Dict[str, List[str]]]:
    """
    Generate a matrix of permissions between multiple users and characters.
    
    This is useful for UI displays and batch permission management.
    
    Args:
        user_ids: List of user IDs
        character_ids: List of character IDs
        
    Returns:
        Nested dictionary mapping user_id -> character_id -> permissions
    """
    matrix = {}
    
    for user_id in user_ids:
        user_key = str(user_id)
        matrix[user_key] = {}
        
        for character_id in character_ids:
            character_key = str(character_id)
            relationship = await get_auth_relationship(user_id, character_id)
            
            if relationship is None:
                matrix[user_key][character_key] = {
                    "permissions": [],
                    "is_owner": False
                }
            else:
                matrix[user_key][character_key] = {
                    "permissions": relationship["data"].get("permissions", []),
                    "is_owner": relationship["data"].get("owner", False)
                }
    
    return matrix

async def check_admin_access(
    user_id: UserId,
    character_ids: List[CharacterId]
) -> Dict[str, Any]:
    """
    Check if a user has admin access (ownership or admin permission) to all specified characters.
    
    Args:
        user_id: The ID of the user
        character_ids: List of character IDs to check
        
    Returns:
        Dictionary with results:
        {
            "has_full_access": bool,  # True if user has admin access to all characters
            "character_access": Dict[str, str]  # Map of character IDs to access level ("owner", "admin", "none")
        }
    """
    result = {
        "has_full_access": True,
        "character_access": {}
    }
    
    for character_id in character_ids:
        relationship = await get_auth_relationship(user_id, character_id)
        
        if relationship is None:
            result["character_access"][str(character_id)] = "none"
            result["has_full_access"] = False
            continue
            
        if relationship["data"].get("owner", False):
            result["character_access"][str(character_id)] = "owner"
        elif "admin" in relationship["data"].get("permissions", []):
            result["character_access"][str(character_id)] = "admin"
        else:
            result["character_access"][str(character_id)] = "none"
            result["has_full_access"] = False
    
    return result

async def create_relationship_group(
    name: str,
    user_ids: List[UserId],
    character_ids: List[CharacterId],
    permissions: List[str] = None,
    is_owner: bool = False
) -> Dict[str, Any]:
    """
    Create a named group of relationships between multiple users and characters.
    This is useful for batch operations like setting up teams or campaigns.
    
    Args:
        name: The name of the relationship group
        user_ids: List of user IDs to include in the group
        character_ids: List of character IDs to include in the group
        permissions: List of permissions to grant to all relationships in this group
        is_owner: Whether all relationships in this group should have owner status
        
    Returns:
        Dictionary with results including created relationships
    """
    if permissions is None:
        permissions = []
    
    results = {
        "name": name,
        "relationships_created": 0,
        "relationships": []
    }
    
    relationships_to_create = []
    for user_id in user_ids:
        for character_id in character_ids:
            relationships_to_create.append({
                "source_id": str(user_id),
                "target_id": str(character_id),
                "permissions": permissions,
                "is_owner": is_owner
            })
    
    created_relationships = await bulk_create_auth_relationships(relationships_to_create)
    results["relationships"] = created_relationships
    results["relationships_created"] = len(created_relationships)
    
    # In a real implementation, you would also save the group metadata to DB
    # This might involve creating a separate "relationship_group" table
    
    return results

async def get_relationship_group_members(
    group_name: str
) -> Dict[str, Any]:
    """
    Get all members (users and characters) of a named relationship group.
    
    Args:
        group_name: The name of the relationship group
        
    Returns:
        Dictionary with user_ids and character_ids in the group
    """
    # In a real implementation, this would query a "relationship_group" table
    # This is just a placeholder
    return {
        "name": group_name,
        "user_ids": [],
        "character_ids": [],
        "created_at": "2023-08-01T00:00:00Z"
    }

async def add_to_relationship_group(
    group_name: str,
    user_ids: Optional[List[UserId]] = None,
    character_ids: Optional[List[CharacterId]] = None,
    permissions: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Add users and/or characters to an existing relationship group.
    
    Args:
        group_name: The name of the relationship group
        user_ids: List of user IDs to add to the group (optional)
        character_ids: List of character IDs to add to the group (optional)
        permissions: List of permissions to grant to new relationships (optional)
        
    Returns:
        Dictionary with results including created relationships
    """
    if user_ids is None:
        user_ids = []
    if character_ids is None:
        character_ids = []
    if permissions is None:
        permissions = []
    
    # First, get existing group members
    group = await get_relationship_group_members(group_name)
    
    # Create new relationships between:
    # 1. New users and all characters (existing + new)
    # 2. Existing users and new characters
    all_character_ids = group["character_ids"] + [str(c_id) for c_id in character_ids if str(c_id) not in group["character_ids"]]
    all_user_ids = group["user_ids"] + [str(u_id) for u_id in user_ids if str(u_id) not in group["user_ids"]]
    
    relationships_to_create = []
    
    # New users with all characters
    for user_id in user_ids:
        if str(user_id) not in group["user_ids"]:
            for character_id in all_character_ids:
                relationships_to_create.append({
                    "source_id": str(user_id),
                    "target_id": character_id,
                    "permissions": permissions,
                    "is_owner": False  # New additions typically aren't owners
                })
    
    # Existing users with new characters
    for character_id in character_ids:
        if str(character_id) not in group["character_ids"]:
            for user_id in group["user_ids"]:
                relationships_to_create.append({
                    "source_id": user_id,
                    "target_id": str(character_id),
                    "permissions": permissions,
                    "is_owner": False  # New additions typically aren't owners
                })
    
    results = {
        "name": group_name,
        "relationships_created": 0,
        "relationships": []
    }
    
    if relationships_to_create:
        created_relationships = await bulk_create_auth_relationships(relationships_to_create)
        results["relationships"] = created_relationships
        results["relationships_created"] = len(created_relationships)
    
    # In a real implementation, you would also update the group metadata in DB
    
    return results

async def get_relationship_history(
    source_id: Optional[UserId] = None,
    target_id: Optional[CharacterId] = None,
    limit: int = 100,
    offset: int = 0
) -> List[Dict[str, Any]]:
    """
    Get the history of changes to authentication relationships.
    Can filter by source user ID, target character ID, or both.
    
    Args:
        source_id: Filter by user ID (optional)
        target_id: Filter by character ID (optional)
        limit: Maximum number of records to return
        offset: Number of records to skip (for pagination)
        
    Returns:
        List of historical relationship changes
    """
    # In a real implementation, this would query an audit/history table
    # This is just a placeholder
    history = [
        {
            "id": "1",
            "source_id": str(source_id) if source_id else "user_1",
            "target_id": str(target_id) if target_id else "character_1",
            "type": "auth",
            "action": "create",
            "previous_data": None,
            "new_data": {
                "permissions": ["play"],
                "owner": True
            },
            "timestamp": "2023-08-01T00:00:00Z",
            "actor_id": str(source_id) if source_id else "user_1"
        }
    ]
    
    return history

async def validate_api_key_access(
    api_key: str,
    character_id: CharacterId,
    required_permission: str
) -> Dict[str, Any]:
    """
    Validate if an API key has access to a character with the required permission.
    This is useful for external API integrations (e.g., Discord bots, third-party tools).
    
    Args:
        api_key: The API key to validate
        character_id: The character ID that the API key is trying to access
        required_permission: The permission required for the operation
        
    Returns:
        Dictionary with validation results:
        {
            "valid": bool,
            "user_id": Optional[str],  # The user ID associated with the API key
            "scopes": List[str],       # The permission scopes granted to the API key
            "expires_at": Optional[str] # Expiration timestamp, if any
        }
    """
    # In a real implementation, this would:
    # 1. Lookup the API key in a database
    # 2. Find the associated user
    # 3. Check if that user has the required permission for the character
    
    # This is just a placeholder
    return {
        "valid": False,
        "user_id": None,
        "scopes": [],
        "expires_at": None,
        "message": "API key validation not implemented"
    }

async def generate_character_api_key(
    user_id: UserId,
    character_id: CharacterId,
    permissions: List[str],
    expires_in_days: Optional[int] = 30
) -> Dict[str, Any]:
    """
    Generate an API key that grants access to a specific character.
    This is useful for external integrations that need to interact with a specific character.
    
    Args:
        user_id: The user generating the API key
        character_id: The character to grant access to
        permissions: List of permissions to grant via this API key
        expires_in_days: Number of days until the key expires (None for no expiration)
        
    Returns:
        Dictionary with the generated API key details
    """
    # In a real implementation, this would:
    # 1. Verify the user has permission to generate keys for this character
    # 2. Generate a secure random key
    # 3. Store it in the database with the given parameters
    # 4. Return the key to the caller (this is the only time it's visible in plain text)
    
    # This is just a placeholder
    import uuid
    import datetime
    
    # Calculate expiration date
    expires_at = None
    if expires_in_days is not None:
        expires_at = datetime.datetime.utcnow() + datetime.timedelta(days=expires_in_days)
        expires_at = expires_at.isoformat() + "Z"
    
    return {
        "api_key": f"vdm_api_{uuid.uuid4().hex}",
        "user_id": str(user_id),
        "character_id": str(character_id),
        "permissions": permissions,
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
        "expires_at": expires_at
    }

async def cache_user_permissions(
    user_id: UserId,
    force_refresh: bool = False
) -> Dict[str, Any]:
    """
    Cache all permission data for a user for faster lookup.
    This is useful for performance optimization in high-traffic scenarios.
    
    Args:
        user_id: The user ID to cache permissions for
        force_refresh: Whether to force a cache refresh even if it exists
        
    Returns:
        Dictionary with cache status and details
    """
    # In a real implementation, this would:
    # 1. Query all relationships for this user
    # 2. Format them for quick lookup
    # 3. Store in a fast cache (Redis, etc.)
    
    # This is just a placeholder
    characters = await get_user_characters(user_id, include_permissions=True)
    
    cache = {
        "user_id": str(user_id),
        "character_permissions": {},
        "cached_at": None,
        "cache_hit": False
    }
    
    # Structure the data for optimal lookup
    for character in characters:
        character_id = character["target_id"]
        permissions = character["data"].get("permissions", [])
        is_owner = character["data"].get("owner", False)
        
        cache["character_permissions"][character_id] = {
            "permissions": permissions,
            "owner": is_owner
        }
    
    import datetime
    cache["cached_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    
    return cache

async def lookup_cached_permission(
    user_id: UserId,
    character_id: CharacterId,
    permission: str
) -> Dict[str, Any]:
    """
    Look up a permission from the cache for extremely fast permission checks.
    
    Args:
        user_id: The user ID to check
        character_id: The character ID to check
        permission: The permission to check
        
    Returns:
        Dictionary with permission status and cache metadata
    """
    # In a real implementation, this would:
    # 1. Check if the user's permissions are cached
    # 2. If not, trigger a cache refresh
    # 3. Look up the permission from the cache
    
    # This is just a placeholder to demonstrate the concept
    cache = await cache_user_permissions(user_id)
    
    result = {
        "has_permission": False,
        "from_cache": True,
        "cache_time": cache["cached_at"]
    }
    
    character_perms = cache["character_permissions"].get(str(character_id))
    if character_perms:
        if character_perms.get("owner", False):
            result["has_permission"] = True
        elif permission in character_perms.get("permissions", []):
            result["has_permission"] = True
    
    return result

async def invalidate_permission_cache(
    user_id: Optional[UserId] = None,
    character_id: Optional[CharacterId] = None
) -> Dict[str, bool]:
    """
    Invalidate the permission cache for a user, character, or both.
    This should be called whenever permissions are updated.
    
    Args:
        user_id: The user ID to invalidate cache for (optional)
        character_id: The character ID to invalidate cache for (optional)
        
    Returns:
        Dictionary with invalidation status
    """
    # In a real implementation, this would delete relevant cache entries
    
    # This is just a placeholder
    return {
        "cache_invalidated": True,
        "user_cache_cleared": user_id is not None,
        "character_cache_cleared": character_id is not None,
        "all_cache_cleared": user_id is None and character_id is None
    } 