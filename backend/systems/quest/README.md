# Quest System

The Quest System manages all quest-related functionality in the game, including quest creation, tracking, progression, and integration with other game systems.

## Core Architecture

The quest system follows a modular design with clear separation of concerns:

- **Models**: Data structures for quests and quest steps
- **Database**: Quest repository for data storage and retrieval
- **Manager**: Quest state management and business logic
- **Generator**: Quest generation utilities
- **Utils**: General utility functions and validators
- **ArcManager**: Character and story arc management
- **NPCQuests**: NPC-generated quests and interactions
- **Integration**: Event-based integration with other game systems

## Key Files

- `models.py`: Core data models for quests and quest steps
- `database.py`: Repository for all quest data storage operations
- `manager.py`: Manages quest state transitions and operations
- `utils.py`: Utility functions for validation and common operations
- `generator.py`: Quest generation capabilities
- `arc_manager.py`: Story and character arc management
- `npc_quests.py`: NPC-initiated quests and related operations
- `integration.py`: Event handlers for integrating with other systems

## Event Integration

The quest system integrates with other game systems through the event bus, responding to events such as:

- `npc:dialogue_completed`: When a player completes a dialogue with an NPC
- `player:item_acquired`: When a player obtains items
- `player:location_changed`: When a player moves to a new location
- `world:time_changed`: When game time advances
- `combat:enemy_defeated`: When a player defeats enemies

## Quest Generation

Quests can be generated in several ways:

1. **NPC-Driven**: Generated by NPCs based on their characteristics
2. **Location-Based**: Based on the player's current location
3. **Character Arc**: Based on the player's background and story arc
4. **Main Story**: As part of the main storyline progression

## Data Flow

1. Events from other systems trigger quest updates or creation
2. `QuestRepository` handles all database operations for quest data
3. `QuestStateManager` manages quest state transitions and business logic
4. Players can accept, complete, abandon, or fail quests through the API
5. Quest progress is updated through steps completion
6. Journal entries record quest progress for narrative purposes

## Usage Examples

### Generating Quests for a Player

```python
from backend.systems.quest import QuestIntegration

# Generate quests for player at current location
quest_ids = QuestIntegration.generate_quests_for_player(player_id)
```

### Updating Quest Progress

```python
from backend.systems.quest import QuestStateManager

# Initialize the quest state manager
manager = QuestStateManager()

# Update a step in a quest
updated_quest = manager.update_step_status(quest_id, step_id, completed=True)
```

### Creating Story Arcs

```python
from backend.systems.quest import ArcManager

# Create a character-based story arc
arc = ArcManager.generate_character_arc(player_id, "noble")
```

### Managing Quest State

```python
from backend.systems.quest import QuestStateManager

# Initialize the quest state manager
manager = QuestStateManager()

# Accept a quest
manager.accept_quest(quest_id, player_id)

# Complete a quest
manager.complete_quest(quest_id, player_id)

# Abandon a quest
manager.abandon_quest(quest_id, player_id)

# Mark a quest as failed
manager.fail_quest(quest_id, player_id, reason="Time limit exceeded")
```

## Contributing

When adding new features to the quest system:

1. Add appropriate models to `models.py`
2. Implement database operations in `database.py`
3. Add business logic to `manager.py` or specialized modules
4. Add utility functions to `utils.py` if needed
5. Update API endpoints in `router.py` if needed
6. Add event handlers to `integration.py` if the feature interacts with other systems
7. Update exports in `__init__.py`
