"""
Core module for loot_utils
Auto-generated by splitting loot_utils.py
"""

from typing import Dict, List, Any, Tuple, Optional
from datetime import datetime, timedelta
import math
import random
import hashlib
from backend.infrastructure.events import EventDispatcher, EventBase

class LootGeneratedEvent(EventBase):
    """Event emitted when loot is generated"""
    event_type: str = "loot.generated"
    monster_levels: List[int]
    gold_amount: int
    item_count: int
    has_quest_item: bool
    has_magical_item: bool
    rarity_level: Optional[str] = None
    source_type: str = "combat"
    location_id: Optional[int] = None
    region_id: Optional[int] = None

class ItemIdentificationEvent(EventBase):
    """Event emitted when an item is identified"""
    event_type: str = "loot.item_identified"
    item_id: str
    item_name: str
    item_rarity: str
    character_id: int
    skill_level: int = 0
    identification_difficulty: int
    success: bool
    discovered_effects: List[Dict[str, Any]] = []

class ItemEnhancementEvent(EventBase):
    """Event emitted when an item is enhanced"""
    event_type: str = "loot.item_enhanced"
    item_id: str
    item_name: str
    original_rarity: str
    new_rarity: str
    enhancement_type: str  # level_up, enchantment, reforge
    enhancement_level: int
    success: bool
    character_id: int
    craft_skill_used: str

class ShopInventoryEvent(EventBase):
    """Event emitted when shop inventory is generated"""
    event_type: str = "loot.shop_inventory_generated"
    shop_id: int
    shop_type: str
    shop_tier: int
    region_id: Optional[int] = None
    faction_id: Optional[int] = None
    item_count: int
    restocking: bool
    economic_factors: Dict[str, float] = {}

class ShopRestockEvent(EventBase):
    """Event emitted when a shop is restocked"""
    event_type: str = "loot.shop_restocked"
    shop_id: int
    shop_type: str
    shop_tier: int
    previous_item_count: int
    new_item_count: int
    total_item_count: int
    region_id: Optional[int] = None

class ShopTransactionEvent(EventBase):
    """Event emitted for shop transactions"""
    event_type: str = "loot.shop_transaction"
    transaction_id: str
    shop_id: int
    character_id: int
    item_id: str
    quantity: int
    gold_amount: int
    transaction_type: str  # purchase or sale
    success: bool

class LootAnalyticsEvent(EventBase):
    """Event for tracking loot-related analytics"""
    event_type: str = "loot.analytics"
    event_category: str  # what type of event (shop_transaction, enhancement, identification)
    event_action: str  # specific action (purchase, attempt, success)
    item_id: str
    item_name: str
    item_rarity: str
    character_id: int
    value: float = 0.0  # gold amount, success rate, etc.
    metadata: Dict[str, Any] = {}

def group_equipment_by_type(equipment_list: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Categorizes equipment items into armor, weapon, and gear pools.
    
    Args:
        equipment_list: List of equipment items
        
    Returns:
        Dictionary with equipment items organized by category
    """
    pool = {"armor": [], "weapon": [], "gear": []}
    for item in equipment_list:
        category = item.get("category")
        if category in pool:
            pool[category].append(item)
        elif category in ["melee", "ranged"]:
            pool["weapon"].append(item)
    return pool

def gpt_name_and_flavor(base_type: str = "item") -> Tuple[str, str]:
    """
    Generates a name and flavor text for an item using GPT.
    
    Args:
        base_type: The type of item to generate a name for
        
    Returns:
        Tuple of (name, flavor_text)
    """
    # Stub — replace with real GPT call
    return (
        f"The Whispering {base_type.title()}",
        f"This {base_type} hums with mysterious power linked to forgotten ruins."
    )

def merge_loot_sets(loot_sets: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Merges multiple loot sets into a single combined set.
    
    Args:
        loot_sets: List of loot bundles to merge
        
    Returns:
        Combined loot bundle
    """
    combined = {"gold": 0, "equipment": [], "quest_item": [], "magical_item": []}
    for loot in loot_sets:
        combined["gold"] += loot.get("gold", 0)
        combined["equipment"].extend(loot.get("equipment", []))
        if loot.get("quest_item"):
            combined["quest_item"].append(loot["quest_item"])
        if loot.get("magical_item"):
            combined["magical_item"].append(loot["magical_item"])
    return combined

def apply_biome_to_loot_table(loot_table: Dict[str, Any], biome_type: str) -> Dict[str, Any]:
    """
    Modify the loot table based on the biome type.
    
    Args:
        loot_table: The base loot table to modify
        biome_type: The type of biome (forest, desert, etc.)
        
    Returns:
        The modified loot table
    """
    # Make a copy to avoid modifying the original
    modified_table = {**loot_table}
    
    if biome_type.lower() == "forest":
        # Forests have more wood and plant materials
        if "crafting_material" in modified_table["item_types"]:
            modified_table["item_types"]["crafting_material"] += 10
            # Adjust other categories to maintain 100%
            modified_table["item_types"]["weapon"] -= 5
            modified_table["item_types"]["armor"] -= 5
            
    elif biome_type.lower() == "mountains":
        # Mountains have more ore and minerals
        if "crafting_material" in modified_table["item_types"]:
            modified_table["item_types"]["crafting_material"] += 15
            # Better weapons in mountain areas (dwarven/mining tools)
            modified_table["item_types"]["weapon"] += 5
            # Adjust other categories
            modified_table["item_types"]["consumable"] -= 10
            modified_table["item_types"]["accessory"] -= 10
            
    elif biome_type.lower() == "desert":
        # Less gold in deserts, but more rare items
        modified_table["gold"]["base_amount"] = int(modified_table["gold"]["base_amount"] * 0.7)
        modified_table["rarities"]["rare"] += 5
        modified_table["rarities"]["common"] -= 5
        
    elif biome_type.lower() == "swamp":
        # Swamps have more potions and alchemical ingredients
        modified_table["item_types"]["consumable"] += 15
        modified_table["item_types"]["weapon"] -= 5
        modified_table["item_types"]["armor"] -= 10
    
    return modified_table

def apply_motif_to_loot_table(loot_table: Dict[str, Any], motif: str) -> Dict[str, Any]:
    """
    Modify the loot table based on the active motif.
    
    Args:
        loot_table: The base loot table to modify
        motif: The current motif affecting the region/location
        
    Returns:
        The modified loot table
    """
    # Make a copy to avoid modifying the original
    modified_table = {**loot_table}
    
    # Apply changes based on motif themes from the Development Bible
    if motif.lower() == "wealth" or motif.lower() == "prosperity":
        # More gold and valuable items 
        modified_table["gold"]["base_amount"] = int(modified_table["gold"]["base_amount"] * 1.5)
        modified_table["rarities"]["rare"] += 5
        modified_table["rarities"]["epic"] += 3
        modified_table["rarities"]["common"] -= 8
        
    elif motif.lower() == "death" or motif.lower() == "ruin":
        # Less gold but more powerful/sinister items
        modified_table["gold"]["base_amount"] = int(modified_table["gold"]["base_amount"] * 0.7)
        modified_table["rarities"]["epic"] += 5
        modified_table["rarities"]["legendary"] += 1
        modified_table["rarities"]["common"] -= 6
        
    elif motif.lower() == "transformation" or motif.lower() == "change":
        # More variety and unexpected items
        modified_table["item_counts"]["min"] += 1
        modified_table["item_counts"]["max"] += 2
        modified_table["rarities"]["uncommon"] += 10
        modified_table["rarities"]["common"] -= 10
        
    elif motif.lower() == "conflict" or motif.lower() == "war":
        # More weapons and armor
        modified_table["item_types"]["weapon"] += 15
        modified_table["item_types"]["armor"] += 10
        modified_table["item_types"]["consumable"] += 5
        modified_table["item_types"]["accessory"] -= 15
        modified_table["item_types"]["crafting_material"] -= 15
        
    return modified_table

def adjust_price_for_supply_demand(
    base_price: int, 
    item_name: str, 
    item_id: int,
    region_id: int
) -> int:
    """
    Adjust item price based on supply and demand in the region.
    
    Args:
        base_price: Starting price
        item_name: Name of the item
        item_id: ID of the item
        region_id: ID of the region
        
    Returns:
        Adjusted price
    """
    # Get current supply and demand values (0-100)
    supply = get_current_supply(item_name, region_id)
    demand = get_current_demand(item_name, region_id)
    
    # Calculate supply/demand ratio (higher means more demand than supply)
    # Avoid division by zero
    if supply == 0:
        supply = 1
    ratio = demand / supply
    
    # Get economic factors for this region
    econ_factors = get_region_economic_factors(region_id)
    
    # Adjust ratio based on region's prosperity and trade volume
    prosperity_factor = econ_factors.get("prosperity", 1.0)
    trade_factor = econ_factors.get("trade_volume", 1.0)
    
    # High prosperity reduces price volatility, high trade increases it
    volatility = 1.0 / prosperity_factor * trade_factor
    
    # Calculate price multiplier
    # At equilibrium (ratio=1), multiplier should be 1.0
    # Allow prices to fluctuate by up to ±50% based on supply/demand
    price_multiplier = 1.0 + ((ratio - 1.0) * 0.5 * volatility)
    
    # Ensure a reasonable range
    price_multiplier = max(0.5, min(2.0, price_multiplier))
    
    # Apply tax rate
    tax_rate = econ_factors.get("tax_rate", 0.1)
    price_with_tax = base_price * (1 + tax_rate)
    
    # Calculate final adjusted price
    adjusted_price = int(price_with_tax * price_multiplier)
    
    # Ensure minimum price of 1
    adjusted_price = max(1, adjusted_price)
    
    # Emit price adjustment event
    dispatcher = EventDispatcher.get_instance()
    dispatcher.publish_sync(PriceAdjustmentEvent(
        item_id=item_id,
        item_name=item_name,
        old_price=base_price,
        new_price=adjusted_price,
        adjustment_factor=price_multiplier,
        reason=f"Supply/demand (S:{supply}, D:{demand})",
        region_id=region_id
    ))
    
    return adjusted_price

def apply_motif_to_prices(
    base_price: int, 
    item_name: str, 
    item_id: int,
    region_id: int, 
    motif: str
) -> int:
    """
    Adjust item price based on the current motif.
    
    Args:
        base_price: Starting price
        item_name: Name of the item
        item_id: ID of the item
        region_id: ID of the region
        motif: Current motif affecting the region
        
    Returns:
        Adjusted price
    """
    # Default: no change
    price_multiplier = 1.0
    reason = f"Motif: {motif} (no effect)"
    
    # Apply effects based on motif - these should align with the motifs in the Development Bible
    motif = motif.lower()
    
    if motif in ["wealth", "prosperity", "abundance"]:
        # Economy is booming - luxury items cost more, essentials cost less
        if "weapon" in item_name.lower() or "armor" in item_name.lower():
            price_multiplier = 1.2
            reason = f"Motif: {motif} (luxury premium)"
        else:
            price_multiplier = 0.9
            reason = f"Motif: {motif} (essential discount)"
    
    elif motif in ["death", "ruin", "decay"]:
        # Economy is suffering - essentials cost more, luxury items cost less
        if "potion" in item_name.lower() or "food" in item_name.lower():
            price_multiplier = 1.5
            reason = f"Motif: {motif} (essential scarcity)"
        else:
            price_multiplier = 0.7
            reason = f"Motif: {motif} (luxury devalued)"
    
    elif motif in ["conflict", "war", "struggle"]:
        # War economy - weapons and armor cost more, luxury items cost less
        if "weapon" in item_name.lower() or "armor" in item_name.lower():
            price_multiplier = 1.5
            reason = f"Motif: {motif} (war premium)"
        elif "jewelry" in item_name.lower() or "luxury" in item_name.lower():
            price_multiplier = 0.6
            reason = f"Motif: {motif} (luxury unwanted)"
    
    elif motif in ["fear", "paranoia", "madness"]:
        # Protection items at premium
        if "shield" in item_name.lower() or "protect" in item_name.lower():
            price_multiplier = 1.4
            reason = f"Motif: {motif} (protection premium)"
    
    elif motif in ["transformation", "change", "rebirth"]:
        # Crafting materials in demand
        if "material" in item_name.lower() or "ingredient" in item_name.lower():
            price_multiplier = 1.3
            reason = f"Motif: {motif} (crafting boom)"
    
    # Apply the adjustment
    adjusted_price = int(base_price * price_multiplier)
    
    # Emit price adjustment event if there was a change
    if price_multiplier != 1.0:
        dispatcher = EventDispatcher.get_instance()
        dispatcher.publish_sync(PriceAdjustmentEvent(
            item_id=item_id,
            item_name=item_name,
            old_price=base_price,
            new_price=adjusted_price,
            adjustment_factor=price_multiplier,
            reason=reason,
            region_id=region_id
        ))
    
    return adjusted_price

def apply_event_to_prices(
    base_price: int, 
    item_name: str, 
    item_id: int,
    region_id: int, 
    event_type: str
) -> int:
    """
    Adjust item price based on world events.
    
    Args:
        base_price: Starting price
        item_name: Name of the item
        item_id: ID of the item
        region_id: ID of the region
        event_type: Type of world event
        
    Returns:
        Adjusted price
    """
    # Default: no change
    price_multiplier = 1.0
    reason = f"Event: {event_type} (no effect)"
    
    # Apply effects based on world events
    event_type = event_type.lower()
    
    if event_type == "famine":
        # Food prices skyrocket, luxury items plummet
        if "food" in item_name.lower() or "ration" in item_name.lower():
            price_multiplier = 3.0
            reason = f"Event: {event_type} (extreme food scarcity)"
        elif "luxury" in item_name.lower() or "jewelry" in item_name.lower():
            price_multiplier = 0.5
            reason = f"Event: {event_type} (luxury unwanted)"
    
    elif event_type == "plague":
        # Healing items at premium, clothing/armor cheaper (fear of contamination)
        if "healing" in item_name.lower() or "potion" in item_name.lower() or "herb" in item_name.lower():
            price_multiplier = 2.5
            reason = f"Event: {event_type} (medicine premium)"
        elif "clothes" in item_name.lower() or "armor" in item_name.lower():
            price_multiplier = 0.7
            reason = f"Event: {event_type} (contamination fear)"
    
    elif event_type == "war":
        # Similar to war motif but more extreme
        if "weapon" in item_name.lower() or "armor" in item_name.lower():
            price_multiplier = 2.0
            reason = f"Event: {event_type} (war demand)"
        elif "luxury" in item_name.lower():
            price_multiplier = 0.4
            reason = f"Event: {event_type} (wartime austerity)"
    
    elif event_type == "festival":
        # Luxury, food, and drink at premium
        if "luxury" in item_name.lower() or "food" in item_name.lower() or "drink" in item_name.lower():
            price_multiplier = 1.5
            reason = f"Event: {event_type} (celebration demand)"
        elif "weapon" in item_name.lower() or "armor" in item_name.lower():
            price_multiplier = 0.8
            reason = f"Event: {event_type} (peaceful time)"
    
    elif event_type == "merchant_caravan":
        # All prices lower due to increased supply
        price_multiplier = 0.8
        reason = f"Event: {event_type} (increased supply)"
    
    # Apply the adjustment
    adjusted_price = int(base_price * price_multiplier)
    
    # Emit price adjustment event if there was a change
    if price_multiplier != 1.0:
        dispatcher = EventDispatcher.get_instance()
        dispatcher.publish_sync(PriceAdjustmentEvent(
            item_id=item_id,
            item_name=item_name,
            old_price=base_price,
            new_price=adjusted_price,
            adjustment_factor=price_multiplier,
            reason=reason,
            region_id=region_id
        ))
    
    return adjusted_price

def log_loot_acquisition(
    character_id: int,
    items: List[Dict[str, Any]],
    gold_amount: int,
    source_type: str,
    location_id: Optional[int] = None,
    region_id: Optional[int] = None
) -> None:
    """
    Logs loot acquisition for analytics.
    
    Args:
        character_id: ID of the character acquiring loot
        items: List of items acquired
        gold_amount: Amount of gold acquired
        source_type: Source of loot (e.g., "combat", "chest", "quest")
        location_id: Optional ID of the location
        region_id: Optional ID of the region
    """
    # Log gold acquisition
    if gold_amount > 0:
        dispatcher = EventDispatcher.get_instance()
        event = LootAnalyticsEvent(
            event_type="loot.analytics",
            event_category="loot",
            event_action="gold_acquired",
            character_id=character_id,
            gold_amount=gold_amount,
            source_type=source_type,
            location_id=location_id,
            region_id=region_id,
            value=float(gold_amount)
        )
        dispatcher.publish_sync(event)
    
    # Log each item acquisition
    for item in items:
        dispatcher = EventDispatcher.get_instance()
        event = LootAnalyticsEvent(
            event_type="loot.analytics",
            event_category="loot",
            event_action="item_acquired",
            item_id=item.get("id", 0),
            item_name=item.get("name", "Unknown Item"),
            item_rarity=item.get("rarity", "common"),
            character_id=character_id,
            source_type=source_type,
            location_id=location_id,
            region_id=region_id,
            value=float(item.get("value", 0)),
            metadata={
                "category": item.get("category", ""),
                "has_effects": len(item.get("effects", [])) > 0,
                "effects_count": len(item.get("effects", []))
            }
        )
        dispatcher.publish_sync(event)
    
    # Log rarity statistics
    rarity_counts = {}
    for item in items:
        rarity = item.get("rarity", "common").lower()
        rarity_counts[rarity] = rarity_counts.get(rarity, 0) + 1
    
    for rarity, count in rarity_counts.items():
        dispatcher = EventDispatcher.get_instance()
        event = LootAnalyticsEvent(
            event_type="loot.analytics",
            event_category="loot",
            event_action="rarity_stats",
            character_id=character_id,
            source_type=source_type,
            item_rarity=rarity,
            location_id=location_id,
            region_id=region_id,
            value=float(count),
            metadata={
                "count": count,
                "percentage": count / len(items) if items else 0
            }
        )
        dispatcher.publish_sync(event)

def log_shop_transaction(
    character_id: int,
    shop_id: int,
    items_bought: List[Dict[str, Any]],
    items_sold: List[Dict[str, Any]],
    gold_spent: int,
    gold_earned: int,
    location_id: Optional[int] = None,
    region_id: Optional[int] = None
) -> None:
    """
    Logs shop transactions for analytics.
    
    Args:
        character_id: ID of the character making the transaction
        shop_id: ID of the shop
        items_bought: List of items bought
        items_sold: List of items sold
        gold_spent: Amount of gold spent
        gold_earned: Amount of gold earned
        location_id: Optional ID of the location
        region_id: Optional ID of the region
    """
    # Log transaction summary
    dispatcher = EventDispatcher.get_instance()
    event = LootAnalyticsEvent(
        event_type="loot.analytics",
        event_category="shop",
        event_action="transaction",
        character_id=character_id,
        location_id=location_id,
        region_id=region_id,
        value=float(gold_spent - gold_earned),  # Net gold flow (negative = player earned)
        metadata={
            "shop_id": shop_id,
            "items_bought": len(items_bought),
            "items_sold": len(items_sold),
            "gold_spent": gold_spent,
            "gold_earned": gold_earned
        }
    )
    dispatcher.publish_sync(event)
    
    # Log items bought
    for item in items_bought:
        dispatcher = EventDispatcher.get_instance()
        event = LootAnalyticsEvent(
            event_type="loot.analytics",
            event_category="shop",
            event_action="item_bought",
            item_id=item.get("id", 0),
            item_name=item.get("name", "Unknown Item"),
            item_rarity=item.get("rarity", "common"),
            character_id=character_id,
            source_type=source_type,
            location_id=location_id,
            region_id=region_id,
            value=float(item.get("price", 0)),
            metadata={
                "shop_id": shop_id,
                "category": item.get("category", ""),
                "base_value": item.get("value", 0),
                "price": item.get("price", 0),
                "markup": item.get("price", 0) / item.get("value", 1) if item.get("value", 0) > 0 else 0
            }
        )
        dispatcher.publish_sync(event)
    
    # Log items sold
    for item in items_sold:
        dispatcher = EventDispatcher.get_instance()
        event = LootAnalyticsEvent(
            event_type="loot.analytics",
            event_category="shop",
            event_action="item_sold",
            item_id=item.get("id", 0),
            item_name=item.get("name", "Unknown Item"),
            item_rarity=item.get("rarity", "common"),
            character_id=character_id,
            source_type=source_type,
            location_id=location_id,
            region_id=region_id,
            value=float(item.get("sell_price", 0)),
            metadata={
                "shop_id": shop_id,
                "category": item.get("category", ""),
                "base_value": item.get("value", 0),
                "sell_price": item.get("sell_price", 0),
                "discount": item.get("sell_price", 0) / item.get("value", 1) if item.get("value", 0) > 0 else 0
            }
        )
        dispatcher.publish_sync(event)

def sell_item_to_shop(
    shop_id: int,
    shop_type: str,
    shop_tier: int,
    item: Dict[str, Any],
    character_id: int,
    negotiation_bonus: int = 0,
    location_id: Optional[int] = None,
    region_id: Optional[int] = None
) -> int:
    """
    Sells an item to a shop.
    
    Args:
        shop_id: ID of the shop
        shop_type: Type of shop
        shop_tier: Tier/quality of the shop
        item: Item to sell
        character_id: ID of the character selling the item
        negotiation_bonus: Bonus to negotiation (0-100)
        location_id: Optional ID of the location
        region_id: Optional ID of the region
        
    Returns:
        The amount of gold received for the item
    """
    # Determine base value
    base_value = item.get("value", 10)
    
    # Calculate sell price based on shop type and item category
    category = item.get("category", "").lower()
    rarity = item.get("rarity", "common").lower()
    
    # Shops pay less for items (base: 40-60% of value depending on tier)
    base_percentage = 0.4 + (shop_tier * 0.05)  # Tier 1: 45%, Tier 5: 65%
    
    # Shops pay more for their specialty items
    specialty_match = {
        "blacksmith": ["weapon", "armor", "tool"],
        "alchemist": ["consumable", "ingredient", "potion"],
        "magic": ["magical_weapon", "magical_armor", "scroll", "potion", "trinket"],
        "clothing": ["clothing"],
        "jeweler": ["jewelry", "trinket"],
        "tavern": ["consumable"]
    }
    
    specialty_bonus = 0.0
    if shop_type in specialty_match and category in specialty_match.get(shop_type, []):
        specialty_bonus = 0.15  # 15% bonus for specialty items
    
    # Rarity bonus (shops pay more for rare items)
    rarity_bonus = {
        "common": 0.0,
        "uncommon": 0.05,
        "rare": 0.1,
        "epic": 0.15,
        "legendary": 0.2
    }.get(rarity, 0.0)
    
    # Apply negotiation bonus
    negotiation_bonus_pct = min(0.2, negotiation_bonus * 0.002)  # 0.2% per point, max 20%
    
    # Calculate final percentage
    final_percentage = base_percentage + specialty_bonus + rarity_bonus + negotiation_bonus_pct
    
    # Calculate final sell price
    sell_price = int(base_value * final_percentage)
    
    # Ensure minimum sell value (at least 1 gold)
    sell_price = max(1, sell_price)
    
    # Emit sell event
    dispatcher = EventDispatcher.get_instance()
    event = ShopItemEvent(
        event_type="shop.item.sold",
        shop_id=shop_id,
        shop_name=f"{shop_type.title()} (Tier {shop_tier})",
        item_id=item.get("id", 0),
        item_name=item.get("name", "Unknown Item"),
        item_rarity=item.get("rarity", "common"),
        price=sell_price,
        character_id=character_id,
        location_id=location_id,
        region_id=region_id
    )
    dispatcher.publish_sync(event)
    
    # Track for analytics
    log_shop_transaction(
        character_id=character_id,
        shop_id=shop_id,
        items_bought=[],
        items_sold=[item],
        gold_spent=0,
        gold_earned=sell_price,
        location_id=location_id,
        region_id=region_id
    )
    
    return sell_price

def apply_rarity_to_item(item: Dict[str, Any], rarity: str) -> None:
    """
    Applies rarity modifiers to an item.
    
    Args:
        item: Item to modify
        rarity: Desired rarity level
    """
    # Set the item rarity
    item["rarity"] = rarity.lower()
    
    # Apply stat modifiers based on rarity
    rarity_multipliers = {
        "common": 1.0,
        "uncommon": 1.5,
        "rare": 2.5,
        "epic": 4.0,
        "legendary": 8.0
    }
    
    multiplier = rarity_multipliers.get(rarity.lower(), 1.0)
    
    # Apply value multiplier
    item["value"] = int(item["value"] * multiplier)
    
    # Apply stat multipliers if they exist
    if "damage" in item:
        item["damage"] = int(item["damage"] * multiplier)
    if "defense" in item:
        item["defense"] = int(item["defense"] * multiplier)
    
    # Add rarity prefix to name for uncommon and above
    if rarity.lower() != "common":
        rarity_prefixes = {
            "uncommon": ["Fine", "Quality", "Superior"],
            "rare": ["Exceptional", "Excellent", "Remarkable"],
            "epic": ["Magnificent", "Splendid", "Exquisite"],
            "legendary": ["Legendary", "Mythical", "Ancient"]
        }
        
        prefixes = rarity_prefixes.get(rarity.lower(), ["Special"])
        prefix = choice(prefixes)
        
        if not item["name"].startswith(prefix):
            item["name"] = f"{prefix} {item['name']}"
    
    # Add special description for higher rarities
    if rarity.lower() in ["rare", "epic", "legendary"]:
        item["description"] += f" This is a {rarity.lower()} item of exceptional quality."

def apply_magical_effects(item: Dict[str, Any], rarity: str, level: int) -> None:
    """
    Applies magical effects to an item.
    
    Args:
        item: Item to modify
        rarity: Rarity level of the item
        level: Level of the item
    """
    # Determine number of effects based on rarity
    effects_count = {
        "common": 0,
        "uncommon": randint(0, 1),
        "rare": randint(1, 2),
        "epic": randint(2, 3),
        "legendary": randint(3, 5)
    }.get(rarity.lower(), 0)
    
    # Don't add effects to common items
    if effects_count == 0:
        return
    
    # Initialize effects array
    if "effects" not in item:
        item["effects"] = []
    
    # Generate effects
    for _ in range(effects_count):
        effect_type = choice(["damage", "defense", "utility", "healing"])
        effect = generate_item_effect(effect_type, rarity)
        if effect:
            item["effects"].append(effect)
    
    # Add magical prefix/suffix to name
    if effects_count > 0 and "of" not in item["name"]:
        magical_suffixes = [
            "of Power", "of the Wise", "of the Berserker", "of Protection",
            "of Speed", "of the Fox", "of the Eagle", "of the Bear",
            "of Flames", "of Frost", "of Thunder", "of Shadows"
        ]
        suffix = choice(magical_suffixes)
        item["name"] = f"{item['name']} {suffix}"
    
    # Mark as magical
    item["is_magical"] = True
    
    # Add identification properties for high-tier items
    if rarity.lower() in ["rare", "epic", "legendary"]:
        item["name_revealed"] = False
        item["generated_name"] = item["name"]
        item["name"] = f"Mysterious {item['category'].title()}"
        item["effects_identified"] = []
    
    # Add visual effect description
    if "visual_effects" not in item:
        item["visual_effects"] = []
    
    # Add a visual effect based on rarity
    visual_effects = {
        "uncommon": "A faint glow surrounds the item.",
        "rare": "The item emits a soft, pulsing light.",
        "epic": "Mystical energies swirl around the item.",
        "legendary": "The item radiates powerful energy and seems to hum with power."
    }
    
    if rarity.lower() in visual_effects:
        item["visual_effects"].append({
            "type": "rarity",
            "description": visual_effects[rarity.lower()]
        })

def apply_thematic_elements(item: Dict[str, Any], faction_id: int = None, motif: str = None) -> None:
    """
    Applies faction or motif-based thematic elements to an item.
    
    Args:
        item: Item to modify
        faction_id: Optional ID of a faction for themed items
        motif: Optional motif to influence item generation
    """
    # Apply faction theming if provided
    if faction_id:
        # In a real implementation, this would look up faction data
        # For now, use placeholder faction data
        faction_themes = {
            1: {"name": "Imperial Legion", "style": "military", "colors": ["gold", "red"]},
            2: {"name": "Merchant Guild", "style": "ornate", "colors": ["purple", "gold"]},
            3: {"name": "Forest Keepers", "style": "natural", "colors": ["green", "brown"]},
            4: {"name": "Arcane Society", "style": "magical", "colors": ["blue", "silver"]}
        }
        
        faction = faction_themes.get(faction_id, {"name": "Unknown", "style": "standard", "colors": ["gray"]})
        
        # Add faction styling
        if "appearance" not in item:
            item["appearance"] = {}
        
        item["appearance"]["faction_style"] = faction["style"]
        item["appearance"]["faction_colors"] = faction["colors"]
        item["appearance"]["description"] = f"This item bears the markings of the {faction['name']}."
        
        # Add faction prefix to name if high enough rarity
        if item["rarity"] in ["rare", "epic", "legendary"]:
            if faction["name"] not in item["name"]:
                if "generated_name" in item:
                    item["generated_name"] = f"{faction['name']} {item['generated_name']}"
                else:
                    item["name"] = f"{faction['name']} {item['name']}"
    
    # Apply motif theming if provided
    if motif:
        # Apply motif-specific modifications
        motif_themes = {
            "fire": {"element": "fire", "colors": ["red", "orange"]},
            "ice": {"element": "ice", "colors": ["blue", "white"]},
            "nature": {"element": "nature", "colors": ["green", "brown"]},
            "undeath": {"element": "undeath", "colors": ["purple", "black"]},
            "sea": {"element": "water", "colors": ["blue", "cyan"]},
            "mountain": {"element": "earth", "colors": ["brown", "gray"]},
            "sky": {"element": "air", "colors": ["light blue", "white"]}
        }
        
        theme = motif_themes.get(motif, {"element": "neutral", "colors": ["beige"]})
        
        # Add motif styling
        if "appearance" not in item:
            item["appearance"] = {}
        
        item["appearance"]["motif_element"] = theme["element"]
        item["appearance"]["motif_colors"] = theme["colors"]
        
        if "description" in item["appearance"]:
            item["appearance"]["description"] += f" It is styled with {theme['element']} elements."
        else:
            item["appearance"]["description"] = f"This item is styled with {theme['element']} elements."
        
        # Add motif effect for magical items
        if item.get("is_magical") and random() < 0.5:
            motif_effects = {
                "fire": "A faint warmth emanates from the item.",
                "ice": "The item feels cool to the touch.",
                "nature": "Small vines or leaves occasionally sprout from the item.",
                "undeath": "The item seems to absorb light around it.",
                "sea": "The item occasionally drips with water that evaporates moments later.",
                "mountain": "The item feels heavier than it looks and is remarkably sturdy.",
                "sky": "The item feels unusually light and occasionally emits a gentle breeze."
            }
            
            effect_desc = motif_effects.get(motif, "The item has a distinctive aura.")
            
            if "visual_effects" not in item:
                item["visual_effects"] = []
            
            item["visual_effects"].append({
                "type": "motif",
                "description": effect_desc
            })

def add_enchantment_to_item(
    item: Dict[str, Any],
    enchantment: Dict[str, Any],
    character_id: int,
    skill_level: int = 0,
    use_catalyst: bool = False,
    catalyst_bonus: int = 0
) -> Tuple[Dict[str, Any], bool, str]:
    """
    Add a new enchantment (effect) to an item.
    
    Args:
        item: The item to enchant
        enchantment: The enchantment to add
        character_id: ID of the character performing enchantment
        skill_level: Character's applicable enchanting skill level
        use_catalyst: Whether using a catalyst to improve chances
        catalyst_bonus: Success bonus from catalyst (percentage points)
        
    Returns:
        Tuple of (updated item, success boolean, result message)
    """
    # Make a copy of the item to avoid modifying the original
    updated_item = item.copy()
    
    # Check if item already has this enchantment
    if "effects" in updated_item:
        for effect in updated_item.get("effects", []):
            if effect.get("id") == enchantment.get("id"):
                return updated_item, False, "This item already has this enchantment."
    
    # Get rarity for difficulty calculation
    rarity = updated_item.get("rarity", "common").lower()
    
    # Base success chance depends on rarity
    base_chance = {
        "common": 85,
        "uncommon": 70,
        "rare": 55,
        "epic": 40,
        "legendary": 25
    }.get(rarity, 50)
    
    # Adjust based on skill
    skill_modifier = (skill_level - 10) * 2  # +2% per skill level above 10
    
    # Adjust based on existing enchantments
    existing_effect_count = len(updated_item.get("effects", []))
    effect_penalty = existing_effect_count * 10  # -10% per existing effect
    
    # Calculate final success chance
    success_chance = base_chance + skill_modifier - effect_penalty
    
    # Add catalyst bonus
    if use_catalyst:
        success_chance += catalyst_bonus
    
    # Ensure minimum and maximum chances
    success_chance = max(5, min(95, success_chance))
    
    # Determine success
    roll = random.randint(1, 100)
    success = roll <= success_chance
    
    result_message = ""
    
    if success:
        # Add the enchantment to the item
        if "effects" not in updated_item:
            updated_item["effects"] = []
        
        # Assign a unique ID if needed
        if "id" not in enchantment:
            enchantment = enchantment.copy()  # Copy to avoid modifying original
            enchantment["id"] = f"ench_{len(updated_item['effects'])}_{random.randint(1000, 9999)}"
        
        updated_item["effects"].append(enchantment)
        
        # Possibly upgrade rarity for powerful enchantments
        enchantment_power = enchantment.get("power", 1)
        rarity_order = ["common", "uncommon", "rare", "epic", "legendary"]
        current_index = rarity_order.index(rarity)
        
        # Very powerful enchantments can increase rarity
        if enchantment_power >= 10 and current_index < len(rarity_order) - 1:
            new_rarity = rarity_order[current_index + 1]
            updated_item["rarity"] = new_rarity
            result_message = f"Enchantment successful! The magical power increased the item's rarity to {new_rarity}!"
        else:
            result_message = f"Enchantment successful! The item now has the '{enchantment.get('name', 'New')}' effect."
    else:
        # Enchantment failed
        
        # Small chance of damaging the item for powerful enchantments
        enchantment_power = enchantment.get("power", 1)
        if enchantment_power >= 8 and existing_effect_count > 0:
            damage_chance = enchantment_power * 3
            if random.randint(1, 100) <= damage_chance:
                # Remove a random effect
                if updated_item.get("effects", []):
                    removed_effect = random.choice(updated_item["effects"])
                    updated_item["effects"].remove(removed_effect)
                    result_message = f"Enchantment failed! The magical backlash removed the '{removed_effect.get('name', 'Existing')}' effect."
                else:
                    result_message = "Enchantment failed."
            else:
                result_message = "Enchantment failed. The item remains unchanged."
        else:
            result_message = "Enchantment failed. The item remains unchanged."
    
    # Create enhancement event
    dispatcher = EventDispatcher.get_instance()
    dispatcher.publish_sync(ItemEnhancementEvent(
        item_id=updated_item.get("id", 0),
        item_name=updated_item.get("name", "Unknown Item"),
        original_rarity=rarity,
        new_rarity=updated_item.get("rarity", rarity),
        enhancement_type="enchantment",
        enhancement_level=len(updated_item.get("effects", [])),
        success=success,
        character_id=character_id,
        craft_skill_used="enchanting"
    ))
    
    # Also log to analytics
    dispatcher.publish_sync(LootAnalyticsEvent(
        event_category="enchantment",
        event_action="attempt",
        item_id=updated_item.get("id", 0),
        item_name=updated_item.get("name", "Unknown Item"),
        item_rarity=updated_item.get("rarity", "common"),
        character_id=character_id,
        value=success_chance,
        metadata={
            "success": success,
            "enchantment_name": enchantment.get("name", "Unknown"),
            "enchantment_power": enchantment.get("power", 1),
            "skill_level": skill_level,
            "use_catalyst": use_catalyst,
            "catalyst_bonus": catalyst_bonus
        }
    ))
    
    return updated_item, success, result_message

def select_rarity():
    rarities = loot_table["rarities"]
    total = sum(rarities.values())
    roll = random.randint(1, total)
    
    cumulative = 0
    for rarity, chance in rarities.items():
        cumulative += chance
        if roll <= cumulative:
            return rarity
    
    return "common"  # Fallback

def select_item_type():
    item_types = loot_table["item_types"]
    total = sum(item_types.values())
    roll = random.randint(1, total)
    
    cumulative = 0
    for item_type, chance in item_types.items():
        cumulative += chance
        if roll <= cumulative:
            return item_type
    
    return "weapon"  # Fallback

# Module-level code
#This module powers structured loot generation with optional GPT flair. It supports generation of gold, equipment, quest items, and magical items based on encounter difficulty. Includes item validation, merging, and progressive identification.
#It is deeply tied into the asset, combat, gpt, and narrative systems.

# Import the event dispatcher

# Event type definitions

# =====================================================================
# === ITEM CATEGORIZATION & ORGANIZATION ==============================
# =====================================================================

# =====================================================================
# === ITEM IDENTITY & NAMING ==========================================
# =====================================================================

# =====================================================================
# === MAGICAL ITEM EFFECT GENERATION =================================
# =====================================================================

# =====================================================================
# === LOOT GENERATION ================================================
# =====================================================================

# =====================================================================
# === LOCATION-BASED LOOT GENERATION =================================
# =====================================================================

# =====================================================================
# === ECONOMY AND DYNAMIC PRICING ====================================
# =====================================================================

# =====================================================================
# === PROGRESSIVE ITEM IDENTIFICATION ================================
# =====================================================================

# =====================================================================
# === ANALYTICS INTEGRATION ==========================================
# =====================================================================

# =====================================================================
# === ITEM RARITY PROGRESSION & ENHANCEMENT ==========================
# =====================================================================

# =====================================================================
# === SHOP MANAGEMENT ===============================================
# =====================================================================

# =====================================================================
# === ITEM GENERATION =================================================
# =====================================================================

