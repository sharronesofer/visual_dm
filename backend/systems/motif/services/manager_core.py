"""
Core module for manager
Auto-generated by splitting manager.py
"""

from typing import List, Dict, Optional, Union, Any, Tuple
from datetime import datetime, timedelta
import logging
import random
import asyncio
from pathlib import Path
from uuid import uuid4

# Use fallback imports for missing dependencies
try:
    from backend.systems.motif.models import (
        Motif, MotifCreate, MotifUpdate, MotifFilter,
        MotifScope, MotifLifecycle, MotifCategory, MotifEffect,
        LocationInfo
    )
except ImportError:
    # Fallback mock classes for resilience
    class MockEnum:
        BETRAYAL = "betrayal"
        CHAOS = "chaos"
        HOPE = "hope"
        GLOBAL = "global"
        EMERGING = "emerging"
        STABLE = "stable"
    
    MotifCategory = MockEnum()
    MotifScope = MockEnum()
    MotifLifecycle = MockEnum()
    
    class Motif:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class MotifCreate:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class MotifUpdate:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class MotifFilter:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class MotifEffect:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class LocationInfo:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

try:
    from backend.systems.motif.service import MotifService
except ImportError:
    class MotifService:
        def __init__(self, repository):
            self.repository = repository
        
        async def create_motif(self, motif_data):
            return Motif(**motif_data.__dict__ if hasattr(motif_data, '__dict__') else motif_data)

try:
from backend.systems.motif.repositories import MotifRepository, Vector2
except ImportError:
    class Vector2:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        
        def distance_to(self, other):
            return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5
    
    class MotifRepository:
        def __init__(self, data_path=None):
            self.data_path = data_path

try:
    from backend.systems.motif.utils import (
        generate_motif_name, generate_motif_description,
        estimate_motif_compatibility, generate_realistic_duration,
        motif_to_narrative_context, calculate_motif_spread,
        roll_chaos_event, NARRATIVE_CHAOS_TABLE
    )
except ImportError:
    # Mock functions if imports fail
    def generate_motif_name(*args, **kwargs):
        return "Mock Motif"
    
    def generate_motif_description(*args, **kwargs):
        return "Mock description"
    
    def estimate_motif_compatibility(*args, **kwargs):
        return 0.5
    
    def generate_realistic_duration(*args, **kwargs):
        return 7
    
    def motif_to_narrative_context(*args, **kwargs):
        return {}
    
    def calculate_motif_spread(*args, **kwargs):
        return {}
    
    def roll_chaos_event(*args, **kwargs):
        return "Mock chaos event"
    
    NARRATIVE_CHAOS_TABLE = ["Mock chaos event"]

try:
    from backend.systems.motif.motif_utils import synthesize_motifs
except ImportError:
    def synthesize_motifs(*args, **kwargs):
        return {"theme": "neutral", "tone": "neutral"}

logger = logging.getLogger(__name__)


class MotifManager:
    """
    Manager class for the Motif system that handles high-level operations
    and coordinates with other systems through events.
    """
    _instance = None
    
    @classmethod
    def get_instance(cls, data_path: str = None) -> 'MotifManager':
        """Get or create the singleton instance."""
        if cls._instance is None:
            cls._instance = cls(data_path)
        return cls._instance
    
    def __init__(self, data_path: str = None):
        """Initialize the MotifManager."""
        if MotifManager._instance is not None:
            logger.warning("MotifManager should be accessed via get_instance()")
        
        self.repository = MotifRepository(data_path)
        self.service = MotifService(self.repository)
        
        # Cache for active motifs to avoid frequent disk I/O
        self._active_motifs_cache = None
        self._cache_timestamp = None
        self._cache_valid_duration = timedelta(minutes=5)
        
        # Event listeners
        self._event_listeners = []
        
        # Background tasks
        self._background_tasks = set()
        
        logger.info("MotifManager initialized")
    
    # ==== Core Motif Operations ====
    
    async def create_motif(self, motif_data: Union[Dict[str, Any], MotifCreate]) -> Motif:
        """
        Create a motif. If motif_data is a dict, it will be converted to a MotifCreate object.
        Returns the created motif.
        """
        if isinstance(motif_data, dict):
            # If name is not provided, generate one
            if "name" not in motif_data and "category" in motif_data and "scope" in motif_data:
                category = motif_data["category"]
                scope = motif_data["scope"]
                motif_data["name"] = generate_motif_name(category, scope)
            
            # If description is not provided, generate one
            if "description" not in motif_data and "category" in motif_data and "scope" in motif_data and "intensity" in motif_data:
                category = motif_data["category"]
                scope = motif_data["scope"]
                intensity = float(motif_data["intensity"])
                motif_data["description"] = generate_motif_description(category, scope, intensity)
            
            # Create the proper MotifCreate object
            motif_data = MotifCreate(**motif_data)
        
        # Create the motif
        motif = await self.service.create_motif(motif_data)
        
        # Invalidate cache
        self._invalidate_cache()
        
        # Emit event for the new motif
        await self._emit_event("motif_created", {"motif": motif.__dict__ if hasattr(motif, '__dict__') else str(motif)})
        
        return motif
    
    async def get_motifs(self, filter_params: Union[Dict[str, Any], MotifFilter, None] = None) -> List[Motif]:
        """
        Get all motifs matching the filter criteria.
        If filter_params is a dict, it will be converted to a MotifFilter object.
        """
        # Use cached motifs if available and valid
        if self._should_use_cache() and filter_params is None:
            return self._active_motifs_cache or []
        
        # Convert dict to filter object if needed
        if isinstance(filter_params, dict):
            filter_params = MotifFilter(**filter_params)
        
        try:
            motifs = await self.service.get_motifs(filter_params)
        except Exception as e:
            logger.error(f"Error getting motifs: {e}")
            motifs = []
        
        # Cache results if no filter was applied
        if filter_params is None:
            self._active_motifs_cache = motifs
            self._cache_timestamp = datetime.now()
        
        return motifs
    
    async def get_motif(self, motif_id: str) -> Optional[Motif]:
        """Get a specific motif by ID."""
        try:
            return await self.service.get_motif(motif_id)
        except Exception as e:
            logger.error(f"Error getting motif {motif_id}: {e}")
            return None
    
    async def update_motif(self, motif_id: str, update_data: Union[Dict[str, Any], MotifUpdate]) -> Optional[Motif]:
        """
        Update an existing motif. If update_data is a dict, it will be converted to a MotifUpdate object.
        Returns the updated motif, or None if motif was not found.
        """
        if isinstance(update_data, dict):
            update_data = MotifUpdate(**update_data)
        
        try:
            motif = await self.service.update_motif(motif_id, update_data)
        except Exception as e:
            logger.error(f"Error updating motif {motif_id}: {e}")
            return None
        
        if motif:
            # Invalidate cache
            self._invalidate_cache()
            
            # Emit event for the updated motif
            await self._emit_event("motif_updated", {"motif": motif.__dict__ if hasattr(motif, '__dict__') else str(motif)})
        
        return motif
    
    async def delete_motif(self, motif_id: str) -> bool:
        """Delete a motif by ID. Returns True if successful, False otherwise."""
        try:
            result = await self.service.delete_motif(motif_id)
        except Exception as e:
            logger.error(f"Error deleting motif {motif_id}: {e}")
            return False
        
        if result:
            # Invalidate cache
            self._invalidate_cache()
            
            # Emit event for the deleted motif
            await self._emit_event("motif_deleted", {"motif_id": motif_id})
        
        return result
    
    # ==== Event Handling ====
    
    def register_event_listener(self, callback):
        """Register a callback for motif events."""
        if callback not in self._event_listeners:
            self._event_listeners.append(callback)
    
    def unregister_event_listener(self, callback):
        """Unregister a callback for motif events."""
        if callback in self._event_listeners:
            self._event_listeners.remove(callback)
    
    async def _emit_event(self, event_type: str, data: Dict[str, Any]):
        """Emit an event to all registered listeners."""
        event = {
            "type": f"motif.{event_type}",
            "timestamp": datetime.now().isoformat(),
            "data": data
        }
        
        for listener in self._event_listeners:
            try:
                # Accept both sync and async callbacks
                if asyncio.iscoroutinefunction(listener):
                    await listener(event)
                else:
                    listener(event)
            except Exception as e:
                logger.error(f"Error in motif event listener: {e}")
    
    # ==== Utility Methods ====
    
    def _should_use_cache(self) -> bool:
        """Check if the cache is valid and should be used."""
        if self._active_motifs_cache is None or self._cache_timestamp is None:
            return False
        
        time_since_cache = datetime.now() - self._cache_timestamp
        return time_since_cache < self._cache_valid_duration
    
    def _invalidate_cache(self):
        """Invalidate the motif cache."""
        self._active_motifs_cache = None
        self._cache_timestamp = None
    
    # ==== Chaos System Integration ====
    
    def roll_chaos_event(self):
        """Generate a random chaos event from the predefined table."""
        return roll_chaos_event()
    
    async def inject_chaos_event(self, event_type, region=None, context=None):
        """
        Inject a chaos event into the world log.
        
        Args:
            event_type: The type of chaos event
            region: Optional region where the event occurs
            context: Additional context data for the event
             
        Returns:
            Dict containing the created event data
        """
        context = context or {}
        event_id = f"chaos_{int(datetime.now().timestamp())}"
        summary = f"[CHAOS EVENT] {event_type}"

        event_data = {
            "event_id": event_id,
            "summary": summary,
            "type": "narrative_chaos",
            "timestamp": datetime.now().isoformat(),
            "context": context
        }

        # Add to world log (using repository instead of direct DB write)
        try:
            await self.repository.add_to_world_log(event_id, event_data)
        except Exception as e:
            logger.error(f"Error adding to world log: {e}")

        # Emit chaos event
        await self._emit_event("chaos_event", event_data)
        
        return event_data

    # ==== Advanced Motif Operations ====
    
    async def get_dominant_motifs(self, limit: int = 3) -> List[Motif]:
        """Get the most dominant/intense motifs in the world."""
        try:
            # First get all active motifs
            all_motifs = await self.get_motifs(MotifFilter(
                lifecycle=[MotifLifecycle.EMERGING, MotifLifecycle.STABLE]
            ))
            
            # Sort by intensity in descending order
            sorted_motifs = sorted(all_motifs, key=lambda m: getattr(m, 'intensity', 0), reverse=True)
            
            # Return the top N motifs
            return sorted_motifs[:limit]
        except Exception as e:
            logger.error(f"Error getting dominant motifs: {e}")
            return []
    
    async def get_narrative_context(self, x: Optional[float] = None, y: Optional[float] = None, region_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Get a comprehensive narrative context dictionary based on active motifs at a position or region.
        This is designed to be used directly in GPT prompts for narrative generation.
        
        Args:
            x, y: Optional coordinates to get motifs at a specific position
            region_id: Optional region ID to get regional motifs
             
        Returns:
            A dictionary with narrative context information based on active motifs
        """
        try:
            # Get the basic motif context
            motif_context = await self.service.get_motif_context(x, y, region_id)
            return motif_context
        except Exception as e:
            logger.error(f"Error getting narrative context: {e}")
            return {
                "active_motifs": [],
                "narrative_themes": [],
                "world_tone": {"primary_influence": "neutral", "intensity": 5}
            }

    # ==== Placeholder methods for comprehensive interface ====
    
    async def generate_random_motif(self, **kwargs) -> Motif:
        """Generate a random motif based on provided parameters."""
        try:
            # Basic motif creation with defaults
            motif_data = {
                "name": "Random Motif",
                "description": "A randomly generated motif",
                "category": getattr(MotifCategory, 'CHAOS', 'chaos'),
                "scope": getattr(MotifScope, 'LOCAL', 'local'),
                "intensity": random.randint(1, 10)
            }
            motif_data.update(kwargs)
            return await self.create_motif(motif_data)
        except Exception as e:
            logger.error(f"Error generating random motif: {e}")
            return None

    async def get_gpt_context(self, **kwargs) -> Dict[str, Any]:
        """Generate a complete GPT context for narrative generation."""
        return await self.get_narrative_context(**kwargs)

