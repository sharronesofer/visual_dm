"""
Tests for Equipment Durability utility functions.
"""

import pytest
from unittest.mock import patch, MagicMock, ANY
import random

# Import the module to test
from backend.systems.equipment.durability_utils import (
    get_durability_status,
    calculate_combat_damage,
    calculate_wear_damage,
    apply_durability_damage,
    calculate_repair_cost,
    repair_equipment,
    adjust_stats_for_durability,
    get_durability_history,
)

# Import models
from backend.systems.equipment.models import Equipment, EquipmentDurabilityLog


# Set a fixed seed for random to make tests deterministic
@pytest.fixture(autouse=True)
def fixed_random_seed():
    """Set a fixed seed for random to make tests deterministic."""
    random.seed(12345)
    yield
    random.seed()  # Reset to random seed after test


class TestDurabilityStatus:
    """Tests for durability status function."""

    @pytest.mark.parametrize(
        "current, max_val, expected_status",
        [
            (100.0, 100.0, "perfect"),
            (95.0, 100.0, "excellent"),
            (80.0, 100.0, "good"),
            (60.0, 100.0, "worn"),
            (30.0, 100.0, "damaged"),
            (5.0, 100.0, "very_damaged"),
            (0.0, 100.0, "broken"),
            # Edge cases
            (0.0, 0.0, "broken"),  # Division by zero case
            (-5.0, 100.0, "broken"),  # Negative durability
        ],
    )
    def test_get_durability_status(self, current, max_val, expected_status):
        """Test get_durability_status returns correct status for various durability levels."""
        status = get_durability_status(current, max_val)
        assert status == expected_status


class TestDamageCalculation:
    """Tests for damage calculation functions."""

    @pytest.mark.parametrize(
        "equipment_type, combat_intensity, is_critical, expected_range",
        [
            ("weapon", 1.0, False, (0.4, 0.6)),  # Normal weapon damage
            ("armor", 1.0, False, (0.16, 0.24)),  # Normal armor damage
            ("shield", 1.0, False, (0.24, 0.36)),  # Normal shield damage
            ("accessory", 1.0, False, (0.08, 0.12)),  # Normal accessory damage
            ("weapon", 2.0, False, (0.8, 1.2)),  # High intensity
            ("weapon", 0.5, False, (0.2, 0.3)),  # Low intensity
            ("weapon", 1.0, True, (0.8, 1.2)),  # Critical hit
            ("unknown", 1.0, False, (0.16, 0.24)),  # Unknown equipment type
        ],
    )
    def test_calculate_combat_damage(
        self, equipment_type, combat_intensity, is_critical, expected_range
    ):
        """Test calculate_combat_damage returns values within expected range."""
        damage = calculate_combat_damage(equipment_type, combat_intensity, is_critical)
        assert expected_range[0] <= damage <= expected_range[1]
        assert isinstance(damage, float)
        assert round(damage, 2) == damage  # Should be rounded to 2 decimal places

    @pytest.mark.parametrize(
        "equipment_type, time_worn, env_factor, expected_range",
        [
            ("weapon", 1.0, 1.0, (0.05, 0.05)),  # Normal weapon wear
            ("armor", 1.0, 1.0, (0.03, 0.03)),  # Normal armor wear
            ("shield", 1.0, 1.0, (0.02, 0.02)),  # Normal shield wear
            ("accessory", 1.0, 1.0, (0.01, 0.01)),  # Normal accessory wear
            ("weapon", 5.0, 1.0, (0.25, 0.25)),  # Long time worn
            ("weapon", 1.0, 2.0, (0.1, 0.1)),  # Harsh environment
            ("unknown", 1.0, 1.0, (0.01, 0.01)),  # Unknown equipment type
        ],
    )
    def test_calculate_wear_damage(
        self, equipment_type, time_worn, env_factor, expected_range
    ):
        """Test calculate_wear_damage returns values within expected range."""
        damage = calculate_wear_damage(equipment_type, time_worn, env_factor)
        assert expected_range[0] <= damage <= expected_range[1]
        assert isinstance(damage, float)
        assert round(damage, 2) == damage  # Should be rounded to 2 decimal places


@pytest.fixture
def mock_db_session():
    """Create a mock database session."""
    with patch("backend.systems.equipment.durability_utils.db") as mock_db:
        mock_db.session = MagicMock()
        yield mock_db


@pytest.fixture
def mock_event_dispatcher():
    """Create a mock event dispatcher."""
    with patch(
        "backend.systems.equipment.durability_utils.EventDispatcher"
    ) as mock_dispatcher:
        mock_instance = MagicMock()
        mock_dispatcher.get_instance.return_value = mock_instance
        yield mock_instance


class TestApplyDurabilityDamage:
    """Tests for apply_durability_damage function."""

    def test_apply_durability_damage_basic(
        self, mock_db_session, mock_event_dispatcher
    ):
        """Test basic durability damage application."""
        # Create equipment mock
        equipment = MagicMock(spec=Equipment)
        equipment.id = 1
        equipment.character_id = 100
        equipment.current_durability = 100.0
        equipment.is_broken = False

        # Set up the log model mock with patch
        log_entry_mock = MagicMock(spec=EquipmentDurabilityLog)
        with patch(
            "backend.systems.equipment.durability_utils.EquipmentDurabilityLog",
            return_value=log_entry_mock,
        ):
            # Define constants used in the function
            with patch(
                "backend.systems.equipment.durability_utils.BROKEN_THRESHOLD", 0.1
            ):
                # Call the function
                result = apply_durability_damage(
                    equipment, 20.0, "combat", {"combat_type": "normal"}
                )

                # Check equipment was updated
                assert equipment.current_durability == 80.0
                assert equipment.is_broken is False

                # Check log entry was created and added
                mock_db_session.session.add.assert_called_once_with(log_entry_mock)

                # Check event was dispatched
                mock_event_dispatcher.publish_sync.assert_called()

    def test_apply_durability_damage_breaks_item(
        self, mock_db_session, mock_event_dispatcher
    ):
        """Test durability damage that breaks the item."""
        # Create equipment mock
        equipment = MagicMock(spec=Equipment)
        equipment.id = 1
        equipment.character_id = 100
        equipment.current_durability = 5.0
        equipment.is_broken = False

        # Set up the log model mock with patch
        log_entry_mock = MagicMock(spec=EquipmentDurabilityLog)
        with patch(
            "backend.systems.equipment.durability_utils.EquipmentDurabilityLog",
            return_value=log_entry_mock,
        ):
            # Define constants used in the function
            with patch(
                "backend.systems.equipment.durability_utils.BROKEN_THRESHOLD", 0.1
            ):
                # Call the function
                result = apply_durability_damage(
                    equipment, 10.0, "combat", {"combat_type": "normal"}
                )

                # Check equipment was updated
                assert equipment.current_durability == 0.0
                assert equipment.is_broken is True

                # Check log entry was created and added
                mock_db_session.session.add.assert_called_once_with(log_entry_mock)

                # Check events were dispatched (including item broken event)
                assert mock_event_dispatcher.publish_sync.call_count >= 2


class TestRepairFunctions:
    """Tests for repair-related functions."""

    @pytest.mark.parametrize(
        "current, max_val, item_value, repair_amount, expected_cost",
        [
            (
                50.0,
                100.0,
                1000,
                None,
                {"base_cost": 500.0, "total_cost": 500.0},
            ),  # 50% damage = 50% cost
            (
                50.0,
                100.0,
                1000,
                25.0,
                {"base_cost": 250.0, "total_cost": 250.0},
            ),  # Partial repair
            (
                90.0,
                100.0,
                1000,
                None,
                {"base_cost": 100.0, "total_cost": 100.0},
            ),  # Minor repair with minimum
            (
                0.0,
                100.0,
                1000,
                None,
                {"base_cost": 1000.0, "total_cost": 1000.0},
            ),  # Full repair from broken
        ],
    )
    def test_calculate_repair_cost(
        self, current, max_val, item_value, repair_amount, expected_cost
    ):
        """Test repair cost calculation for different scenarios."""
        result = calculate_repair_cost(current, max_val, item_value, repair_amount)
        assert result["base_cost"] == expected_cost["base_cost"]
        assert result["total_cost"] == expected_cost["total_cost"]

    def test_repair_equipment(self, mock_db_session, mock_event_dispatcher):
        """Test repairing equipment."""
        # Create equipment mock
        equipment = MagicMock(spec=Equipment)
        equipment.id = 1
        equipment.character_id = 100
        equipment.current_durability = 50.0
        equipment.max_durability = 100.0
        equipment.is_broken = False

        # Set up the log model mock with patch
        log_entry_mock = MagicMock(spec=EquipmentDurabilityLog)
        with patch(
            "backend.systems.equipment.durability_utils.EquipmentDurabilityLog",
            return_value=log_entry_mock,
        ):
            # Call the function for partial repair
            amount_repaired = repair_equipment(equipment, 25.0, False)

            # Check equipment was updated
            assert equipment.current_durability == 75.0
            assert equipment.is_broken is False
            assert amount_repaired == 25.0

            # Check log entry was created and added
            mock_db_session.session.add.assert_called_once_with(log_entry_mock)

            # Check event was dispatched
            mock_event_dispatcher.publish_sync.assert_called()

    def test_repair_equipment_full(self, mock_db_session, mock_event_dispatcher):
        """Test full equipment repair."""
        # Create equipment mock
        equipment = MagicMock(spec=Equipment)
        equipment.id = 1
        equipment.character_id = 100
        equipment.current_durability = 50.0
        equipment.max_durability = 100.0
        equipment.is_broken = True

        # Set up the log model mock with patch
        log_entry_mock = MagicMock(spec=EquipmentDurabilityLog)
        with patch(
            "backend.systems.equipment.durability_utils.EquipmentDurabilityLog",
            return_value=log_entry_mock,
        ):
            # Call the function for full repair
            amount_repaired = repair_equipment(equipment, None, True)

            # Check equipment was updated
            assert equipment.current_durability == 100.0
            assert equipment.is_broken is False
            assert amount_repaired == 50.0

            # Check log entry was created and added
            mock_db_session.session.add.assert_called_once_with(log_entry_mock)

            # Check events were dispatched (including unbroken event)
            assert mock_event_dispatcher.publish_sync.call_count >= 2


class TestStatAdjustments:
    """Tests for stat adjustment functions."""

    @pytest.mark.parametrize(
        "durability_status, expected_penalty",
        [
            ("excellent", 0.0),  # No penalty
            ("good", 0.0),  # No penalty
            ("worn", 0.1),  # 10% penalty
            ("damaged", 0.25),  # 25% penalty
            ("very_damaged", 0.5),  # 50% penalty
            ("broken", 1.0),  # 100% penalty (item doesn't work)
        ],
    )
    def test_adjust_stats_for_durability(self, durability_status, expected_penalty):
        """Test stat adjustments based on durability status."""
        # Mock an equipment item and its stats
        equipment = {
            "current_durability": 50.0,
            "max_durability": 100.0,
            "durability_status": durability_status,
        }

        item_stats = {
            "damage": 10,
            "defense": 5,
            "effects": ["fire_resistance"],
            "is_magical": True,
        }

        # Patch the function that gets durability status
        with patch(
            "backend.systems.equipment.durability_utils.get_durability_status",
            return_value=durability_status,
        ):
            # Call the function
            result = adjust_stats_for_durability(equipment, item_stats)

            # Check stats were adjusted correctly
            if durability_status == "broken":
                # Broken items should have no stats
                assert result == {"is_broken": True, "original_stats": item_stats}
            else:
                expected_damage = 10 * (1 - expected_penalty)
                expected_defense = 5 * (1 - expected_penalty)

                assert result["damage"] == expected_damage
                assert result["defense"] == expected_defense
                assert result["effects"] == ["fire_resistance"]
                assert result["is_magical"] == True
                assert result["durability_status"] == durability_status
                assert result["durability_penalty"] == expected_penalty


class TestDurabilityHistory:
    """Tests for durability history functions."""

    def test_get_durability_history(self, mock_db_session):
        """Test getting durability history."""
        # Mock the query results
        mock_log_entries = [
            MagicMock(spec=EquipmentDurabilityLog),
            MagicMock(spec=EquipmentDurabilityLog),
        ]

        # Set up to_dict() for each mock
        mock_log_entries[0].to_dict.return_value = {"id": 1, "change_reason": "combat"}
        mock_log_entries[1].to_dict.return_value = {"id": 2, "change_reason": "repair"}

        # Set up the query mock
        mock_query = MagicMock()
        mock_query.filter_by.return_value = mock_query
        mock_query.order_by.return_value = mock_query
        mock_query.limit.return_value = mock_query
        mock_query.all.return_value = mock_log_entries

        # Mock the model query
        with patch(
            "backend.systems.equipment.durability_utils.EquipmentDurabilityLog.query",
            mock_query,
        ):
            # Call the function
            result = get_durability_history(1, 10)

            # Check the query was called correctly
            mock_query.filter_by.assert_called_once_with(equipment_id=1)
            mock_query.limit.assert_called_once_with(10)

            # Check the result contains the expected entries
            assert len(result) == 2
            assert result[0]["id"] == 1
            assert result[0]["change_reason"] == "combat"
            assert result[1]["id"] == 2
            assert result[1]["change_reason"] == "repair"
