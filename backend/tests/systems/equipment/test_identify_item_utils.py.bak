"""
Tests for equipment identify_item_utils module.
"""

import pytest
from unittest.mock import patch, MagicMock

# Import the utils to test
from backend.systems.equipment.identify_item_utils import (
    calculate_identification_cost,
    identify_item,
    reveal_item_name_and_flavor,
    ItemIdentifiedEvent,
    ItemNameRevealedEvent,
)


class TestIdentifyItemUtils:
    """Test suite for item identification utilities."""

    def test_rarity_multipliers(self):
        """Test that different rarities affect the identification cost."""
        # Test item with common rarity
        common_item = {"rarity": "common", "unknown_effects": ["effect1", "effect2"]}
        common_cost = calculate_identification_cost(common_item)

        # Test item with epic rarity
        epic_item = {"rarity": "epic", "unknown_effects": ["effect1", "effect2"]}
        epic_cost = calculate_identification_cost(epic_item)

        # Epic should cost more than common
        assert epic_cost > common_cost

        # Test ratios between different rarities
        assert epic_cost == int(common_cost * 2.0)  # Epic has 2x multiplier

        # Test legendary
        legendary_item = {
            "rarity": "legendary",
            "unknown_effects": ["effect1", "effect2"],
        }
        legendary_cost = calculate_identification_cost(legendary_item)
        assert legendary_cost == int(common_cost * 4.0)  # Legendary has 4x multiplier

    def test_effect_count_affects_cost(self):
        """Test that the number of unknown effects affects the identification cost."""
        # Test item with one unknown effect
        item_one_effect = {"rarity": "common", "unknown_effects": ["effect1"]}
        cost_one = calculate_identification_cost(item_one_effect)

        # Test item with three unknown effects
        item_three_effects = {
            "rarity": "common",
            "unknown_effects": ["effect1", "effect2", "effect3"],
        }
        cost_three = calculate_identification_cost(item_three_effects)

        # More effects should mean higher cost
        assert cost_three > cost_one
        assert cost_three == cost_one * 3

    @patch("backend.systems.equipment.identify_item_utils.HAS_DATABASE", True)
    @patch("backend.systems.equipment.identify_item_utils.Economy")
    def test_economic_modifier_affects_cost(self, mock_economy):
        """Test that regional economic modifiers affect identification cost."""
        # Setup mock economy data
        mock_economy_instance = MagicMock()
        mock_economy_instance.modifier = 1.5  # 50% higher prices
        mock_economy.query.filter_by.return_value.first.return_value = (
            mock_economy_instance
        )

        # Calculate costs
        item = {"rarity": "uncommon", "unknown_effects": ["effect1"]}
        base_cost = calculate_identification_cost(item)  # Without region
        regional_cost = calculate_identification_cost(
            item, region_name="expensive_region"
        )

        # Regional cost should be higher
        assert regional_cost > base_cost
        assert regional_cost == int(base_cost * 1.5)

        # Verify the mock was called correctly
        mock_economy.query.filter_by.assert_called_once_with(region="expensive_region")

    @patch("backend.systems.equipment.identify_item_utils.HAS_DATABASE", True)
    @patch("backend.systems.equipment.identify_item_utils.Faction")
    def test_faction_discount_affects_cost(self, mock_faction):
        """Test that faction membership can provide identification discounts."""
        # Setup mock faction data
        mock_faction_instance = MagicMock()
        mock_faction_instance.type = "mage"  # Mage guild offers discount
        mock_faction.query.filter_by.return_value.first.return_value = (
            mock_faction_instance
        )

        # Calculate costs
        item = {"rarity": "rare", "unknown_effects": ["effect1"]}
        base_cost = calculate_identification_cost(item)  # Without faction
        faction_cost = calculate_identification_cost(item, faction_id=42)

        # Faction cost should be lower (15% discount)
        assert faction_cost < base_cost
        assert faction_cost == int(base_cost * 0.85)

        # Verify the mock was called correctly
        mock_faction.query.filter_by.assert_called_once_with(id=42)

    @patch("backend.systems.equipment.identify_item_utils.EventDispatcher")
    def test_identify_specific_effect(self, mock_event_dispatcher):
        """Test identifying a specific effect on an item."""
        # Setup mock event dispatcher
        mock_dispatcher_instance = MagicMock()
        mock_event_dispatcher.get_instance.return_value = mock_dispatcher_instance

        # Call identify_item with a specific effect index
        result = identify_item(
            item_id=123, character_id=456, identify_all=False, identify_effect_idx=0
        )

        # Check result
        assert result["success"] is True
        assert len(result["identified_effects"]) == 1
        assert result["identified_effects"][0]["name"] == "First Effect"

        # Verify events were dispatched
        assert mock_dispatcher_instance.publish_sync.call_count >= 1

        # Get the first event that was published
        first_call_args = mock_dispatcher_instance.publish_sync.call_args_list[0][0]
        first_event = first_call_args[0]

        # Check it's an ItemIdentifiedEvent with correct data
        assert isinstance(first_event, ItemIdentifiedEvent)
        assert first_event.item_id == 123
        assert first_event.character_id == 456
        assert "First Effect" in first_event.effects_revealed

    @patch("backend.systems.equipment.identify_item_utils.EventDispatcher")
    def test_identify_all_effects(self, mock_event_dispatcher):
        """Test identifying all effects at once."""
        # Setup mock event dispatcher
        mock_dispatcher_instance = MagicMock()
        mock_event_dispatcher.get_instance.return_value = mock_dispatcher_instance

        # Call identify_item with identify_all=True
        result = identify_item(item_id=123, character_id=456, identify_all=True)

        # Check result
        assert result["success"] is True
        assert len(result["identified_effects"]) == 2
        assert result["all_identified"] is True

        # Verify events were dispatched
        assert mock_dispatcher_instance.publish_sync.call_count >= 1

        # Get the first event that was published
        first_call_args = mock_dispatcher_instance.publish_sync.call_args_list[0][0]
        first_event = first_call_args[0]

        # Check it's an ItemIdentifiedEvent with correct data
        assert isinstance(first_event, ItemIdentifiedEvent)
        assert first_event.item_id == 123
        assert first_event.character_id == 456
        assert len(first_event.effects_revealed) == 2
        assert first_event.fully_identified is True

    @patch("backend.systems.equipment.identify_item_utils.EventDispatcher")
    def test_identify_already_identified_effect(self, mock_event_dispatcher):
        """Test attempting to identify an effect that's already identified."""
        # First identify effect 0
        identify_item(
            item_id=123, character_id=456, identify_all=False, identify_effect_idx=0
        )

        # Reset mock to clear previous calls
        mock_dispatcher_instance = MagicMock()
        mock_event_dispatcher.get_instance.return_value = mock_dispatcher_instance

        # Try to identify the same effect again
        result = identify_item(
            item_id=123, character_id=456, identify_all=False, identify_effect_idx=0
        )

        # Check result indicates failure
        assert result["success"] is False
        assert "already identified" in result["message"].lower()

        # Verify no events were dispatched
        mock_dispatcher_instance.publish_sync.assert_not_called()

    @patch("backend.systems.equipment.identify_item_utils.EventDispatcher")
    def test_reveal_item_name_and_flavor(self, mock_event_dispatcher):
        """Test revealing an item's true name and flavor text."""
        # Setup mock event dispatcher
        mock_dispatcher_instance = MagicMock()
        mock_event_dispatcher.get_instance.return_value = mock_dispatcher_instance

        # Call reveal_item_name_and_flavor
        result = reveal_item_name_and_flavor(item_id=123, character_id=456)

        # Check result
        assert result["success"] is True
        assert "name" in result
        assert "flavor_text" in result

        # Verify events were dispatched
        assert mock_dispatcher_instance.publish_sync.call_count >= 1

        # Find the ItemNameRevealedEvent that was published
        name_revealed_event = None
        for call_args in mock_dispatcher_instance.publish_sync.call_args_list:
            event = call_args[0][0]
            if isinstance(event, ItemNameRevealedEvent):
                name_revealed_event = event
                break

        # Check event data
        assert name_revealed_event is not None
        assert name_revealed_event.item_id == 123
        assert name_revealed_event.character_id == 456
        assert name_revealed_event.revealed_name.startswith("Ancient Artifact")
