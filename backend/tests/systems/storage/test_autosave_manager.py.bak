"""
Unit tests for the AutosaveManager class.

These tests verify that:
1. Configuration works correctly
2. Path registration works
3. Autosave functionality works
4. Checkpoint creation and restoration work
5. Cleanup of old saves works
"""

import pytest
import asyncio
from datetime import datetime, timedelta
from unittest.mock import patch, MagicMock, AsyncMock, call

from backend.systems.storage.autosave_manager import AutosaveManager

class TestAutosaveManager:
    """Test suite for the AutosaveManager class."""
    
    @pytest.fixture
    def mock_storage_manager(self):
        """Create a mock StorageManager."""
        with patch('backend.systems.storage.storage_service.StorageManager.get_instance') as mock:
            # Setup mock methods
            mock_instance = AsyncMock()
            mock.return_value = mock_instance
            
            # Configure get/set/exists methods
            mock_instance.get = AsyncMock(side_effect=lambda path: {"data": "test"} if "exists" in path else None)
            mock_instance.set = AsyncMock()
            mock_instance.exists = AsyncMock(return_value=True)
            mock_instance.list = AsyncMock(return_value={})
            
            yield mock_instance
    
    @pytest.fixture
    def autosave_manager(self, mock_storage_manager):
        """Create a pre-configured AutosaveManager with mock storage."""
        manager = AutosaveManager.get_instance()
        manager.storage_manager = mock_storage_manager
        manager.configure(
            interval_minutes=5,
            autosave_retention=3,
            checkpoint_retention=5
        )
        
        # Register paths
        manager.register_path("player/inventory")
        manager.register_path("player/stats")
        
        # Cancel any existing tasks
        if manager.autosave_task:
            manager.autosave_task.cancel()
        
        yield manager
        
        # Reset singleton for other tests
        AutosaveManager._instance = None
    
    def test_singleton_pattern(self):
        """Test that the singleton pattern works correctly."""
        instance1 = AutosaveManager.get_instance()
        instance2 = AutosaveManager.get_instance()
        
        assert instance1 is instance2
    
    def test_configure(self, autosave_manager):
        """Test that configure() sets parameters correctly."""
        autosave_manager.configure(
            interval_minutes=10,
            autosave_retention=7,
            checkpoint_retention=14
        )
        
        assert autosave_manager.autosave_interval == timedelta(minutes=10)
        assert autosave_manager.autosave_retention == 7
        assert autosave_manager.checkpoint_retention == 14
    
    def test_register_path(self, autosave_manager):
        """Test that register_path() adds paths correctly."""
        # Register a new path
        autosave_manager.register_path("world/state")
        
        # Verify it was added
        assert "world/state" in autosave_manager.autosave_paths
        
        # Register an existing path (should not duplicate)
        autosave_manager.register_path("player/inventory")
        
        # Count occurrences
        path_count = autosave_manager.autosave_paths.count("player/inventory")
        assert path_count == 1, "Path should not be duplicated"
    
    def test_register_save_handler(self, autosave_manager):
        """Test that register_save_handler() adds handlers correctly."""
        # Create a mock handler
        mock_handler = AsyncMock()
        
        # Register the handler
        autosave_manager.register_save_handler("test_object", mock_handler)
        
        # Verify it was added
        assert "test_object" in autosave_manager.save_handlers
        assert autosave_manager.save_handlers["test_object"] == mock_handler
    
    @pytest.mark.asyncio
    async def test_start_stop(self, autosave_manager):
        """Test that start() and stop() work correctly."""
        with patch.object(asyncio, 'create_task', return_value=MagicMock()) as mock_create_task:
            # Start the autosave task
            await autosave_manager.start()
            
            # Verify task was created
            assert autosave_manager.is_running
            assert autosave_manager.autosave_task is not None
            mock_create_task.assert_called_once()
            
            # Stop the autosave task
            await autosave_manager.stop()
            
            # Verify task was cancelled
            assert not autosave_manager.is_running
            assert autosave_manager.autosave_task is None
    
    @pytest.mark.asyncio
    async def test_create_checkpoint(self, autosave_manager, mock_storage_manager):
        """Test that create_checkpoint() works correctly."""
        # Create a checkpoint
        checkpoint_name = await autosave_manager.create_checkpoint("test_checkpoint")
        
        # Verify checkpoint metadata was saved
        mock_storage_manager.set.assert_any_call("checkpoints/latest", {
            "timestamp": mock_storage_manager.set.call_args_list[0][0][1]["timestamp"],
            "type": "checkpoint",
            "name": "test_checkpoint"
        })
        
        # Verify checkpoint data was saved for each registered path
        mock_storage_manager.set.assert_any_call("checkpoints/test_checkpoint/player/inventory", {"data": "test"})
        mock_storage_manager.set.assert_any_call("checkpoints/test_checkpoint/player/stats", {"data": "test"})
    
    @pytest.mark.asyncio
    async def test_create_checkpoint_with_save_handlers(self, autosave_manager, mock_storage_manager):
        """Test that create_checkpoint() calls save handlers."""
        # Create a mock handler
        mock_handler = AsyncMock()
        
        # Register the handler
        autosave_manager.register_save_handler("test_object", mock_handler)
        
        # Create a checkpoint
        checkpoint_name = await autosave_manager.create_checkpoint("test_checkpoint")
        
        # Verify handler was called
        mock_handler.assert_called_once_with("checkpoints/test_checkpoint")
    
    @pytest.mark.asyncio
    async def test_cleanup_checkpoints(self, autosave_manager, mock_storage_manager):
        """Test that _cleanup_checkpoints() works correctly."""
        # Setup mock to return checkpoints
        mock_storage_manager.list.return_value = {
            "checkpoint_1": {"timestamp": (datetime.utcnow() - timedelta(days=10)).isoformat()},
            "checkpoint_2": {"timestamp": (datetime.utcnow() - timedelta(days=5)).isoformat()},
            "checkpoint_3": {"timestamp": (datetime.utcnow() - timedelta(days=1)).isoformat()},
            "checkpoint_4": {"timestamp": datetime.utcnow().isoformat()},
            "checkpoint_5": {"timestamp": datetime.utcnow().isoformat()},
            "checkpoint_6": {"timestamp": datetime.utcnow().isoformat()},
        }
        
        # Call cleanup
        await autosave_manager._cleanup_checkpoints()
        
        # Verify old checkpoints were deleted (oldest should be deleted first)
        mock_storage_manager.delete.assert_has_calls([
            call("checkpoints/checkpoint_1"),
        ])
    
    @pytest.mark.asyncio
    async def test_perform_autosave(self, autosave_manager, mock_storage_manager):
        """Test that _perform_autosave() works correctly."""
        # Call perform_autosave
        await autosave_manager._perform_autosave()
        
        # Verify autosave metadata was saved
        metadata_calls = [
            call for call in mock_storage_manager.set.call_args_list 
            if call[0][0] == "autosaves/latest"
        ]
        assert len(metadata_calls) == 1
        metadata = metadata_calls[0][0][1]
        assert metadata["type"] == "autosave"
        
        # Verify autosave data was saved for each registered path
        path_calls = [
            call for call in mock_storage_manager.set.call_args_list 
            if "player/inventory" in call[0][0] or "player/stats" in call[0][0]
        ]
        assert len(path_calls) == 2
    
    @pytest.mark.asyncio
    async def test_restore_checkpoint(self, autosave_manager, mock_storage_manager):
        """Test that restore_checkpoint() works correctly."""
        # Setup mock checkpoint data
        mock_storage_manager.get.side_effect = lambda path: {
            "checkpoints/test_checkpoint/player/inventory": {"items": ["sword", "potion"]},
            "checkpoints/test_checkpoint/player/stats": {"health": 100, "mana": 50},
        }.get(path, None)
        
        # Restore checkpoint
        await autosave_manager.restore_checkpoint("test_checkpoint")
        
        # Verify data was restored
        mock_storage_manager.set.assert_any_call("player/inventory", {"items": ["sword", "potion"]})
        mock_storage_manager.set.assert_any_call("player/stats", {"health": 100, "mana": 50})
    
    @pytest.mark.asyncio
    async def test_restore_latest_autosave(self, autosave_manager, mock_storage_manager):
        """Test that restore_latest_autosave() works correctly."""
        # Setup mock for latest autosave
        mock_storage_manager.get.side_effect = lambda path: {
            "autosaves/latest": {"name": "autosave_2023-01-01"},
            "autosaves/autosave_2023-01-01/player/inventory": {"items": ["shield", "potion"]},
            "autosaves/autosave_2023-01-01/player/stats": {"health": 80, "mana": 40},
        }.get(path, None)
        
        # Restore latest autosave
        await autosave_manager.restore_latest_autosave()
        
        # Verify data was restored
        mock_storage_manager.set.assert_any_call("player/inventory", {"items": ["shield", "potion"]})
        mock_storage_manager.set.assert_any_call("player/stats", {"health": 80, "mana": 40}) 