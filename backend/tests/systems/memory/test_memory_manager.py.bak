"""
Tests for the MemoryManager class in the memory system.
"""

import json
import pytest
import asyncio
from unittest.mock import MagicMock, AsyncMock, patch
from datetime import datetime, timedelta
import time

from backend.systems.memory import (
    MemoryManager,
    Memory,
    MemoryType,
    MemoryEmotionalValence,
)


class TestMemoryManager:
    """Tests for the MemoryManager class."""

    @pytest.fixture(autouse=True)
    def reset_singleton(self):
        """Reset the MemoryManager singleton instances before each test."""
        # Save the original instances
        original_instances = MemoryManager._instances.copy()
        # Reset for the test
        MemoryManager._instances.clear()
        # Run the test
        yield
        # Restore the original instances after the test
        MemoryManager._instances = original_instances

    @pytest.fixture
    def mock_storage(self):
        """Create a mock storage object for testing."""
        mock = AsyncMock()
        mock.get_memories = AsyncMock(return_value={})
        mock.save_memory = AsyncMock()
        mock.save_all_memories = AsyncMock()
        mock.delete_memory = AsyncMock()
        return mock

    @pytest.fixture
    def mock_event_dispatcher(self):
        """Create a mock event dispatcher for testing."""
        mock = AsyncMock()
        mock.publish = AsyncMock()
        mock.subscribe = MagicMock()
        return mock

    @pytest.fixture
    async def memory_manager(self, mock_storage, mock_event_dispatcher):
        """Create a MemoryManager instance with mocked dependencies."""
        # Create instance using the new pattern
        manager = await MemoryManager.get_instance(
            entity_id="test_entity",
            storage_manager=mock_storage,
            event_dispatcher=mock_event_dispatcher,
        )

        # Return for use in tests
        return manager

    @pytest.mark.asyncio
    async def test_create_memory(self, memory_manager, mock_event_dispatcher):
        """Test that memories can be created correctly."""
        # Arrange
        content = "A test memory"
        importance = 0.8
        entities_involved = ["entity1", "entity2"]

        # Act
        memory = await memory_manager.create_memory(
            content=content, importance=importance, entities_involved=entities_involved
        )

        # Assert
        assert memory.owner_id == "test_entity"
        assert memory.content == content
        assert memory.importance == importance
        assert memory.entities_involved == entities_involved

        # Verify event was published
        mock_event_dispatcher.publish.assert_called_once()
        event = mock_event_dispatcher.publish.call_args[0][0]
        assert event.event_type == "memory.created"
        assert event.entity_id == "test_entity"

    @pytest.mark.asyncio
    async def test_get_memories_by_tag(self, memory_manager):
        """Test retrieving memories by tag."""
        # Arrange
        memory1 = Memory(
            owner_id="test_entity",
            content="Important memory",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.9,
            tags=["important", "test"],
        )
        memory2 = Memory(
            owner_id="test_entity",
            content="Regular memory",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.5,
            tags=["regular"],
        )

        # Add to manager
        await memory_manager.add_memory(memory1)
        await memory_manager.add_memory(memory2)

        # Act
        important_memories = await memory_manager.get_memories_by_tag("important")

        # Assert
        assert len(important_memories) == 1
        assert important_memories[0].id == memory1.id

    @pytest.mark.asyncio
    async def test_get_memories_involving_entity(self, memory_manager):
        """Test retrieving memories involving a specific entity."""
        # Arrange
        memory1 = Memory(
            owner_id="test_entity",
            content="Met player at tavern",
            memory_type=MemoryType.INTERACTION,
            importance=0.7,
            entities_involved=["player_001"],
        )
        memory2 = Memory(
            owner_id="test_entity",
            content="Saw a dragon",
            memory_type=MemoryType.OBSERVATION,
            importance=0.9,
            entities_involved=["dragon_001"],
        )

        # Add to manager
        await memory_manager.add_memory(memory1)
        await memory_manager.add_memory(memory2)

        # Act
        player_memories = await memory_manager.get_memories_involving_entity(
            "player_001"
        )

        # Assert
        assert len(player_memories) == 1
        assert player_memories[0].id == memory1.id

    @pytest.mark.asyncio
    async def test_update_memory_importance(self, memory_manager, mock_storage):
        """Test updating a memory's importance."""
        # Arrange
        memory = Memory(
            owner_id="test_entity",
            content="Memory with changing importance",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.5,
        )
        await memory_manager.add_memory(memory)

        # Act
        updated_memory = await memory_manager.update_memory_importance(memory.id, 0.8)

        # Assert
        assert updated_memory is not None
        assert updated_memory.importance == 0.8
        assert memory_manager.memories[memory.id].importance == 0.8

    @pytest.mark.asyncio
    async def test_delete_memory(
        self, memory_manager, mock_storage, mock_event_dispatcher
    ):
        """Test deleting a memory."""
        # Arrange
        memory = Memory(
            owner_id="test_entity",
            content="Memory to be deleted",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.5,
        )
        await memory_manager.add_memory(memory)

        # Act
        result = await memory_manager.delete_memory(memory.id)

        # Assert
        assert result is True
        assert memory.id not in memory_manager.memories

        # Verify event was published
        mock_event_dispatcher.publish.assert_called()
        # Find the memory.forgotten event
        forgotten_event = None
        for call in mock_event_dispatcher.publish.call_args_list:
            event = call[0][0]
            if event.event_type == "memory.forgotten":
                forgotten_event = event
                break

        assert forgotten_event is not None
        assert forgotten_event.entity_id == "test_entity"

    @pytest.mark.asyncio
    async def test_recall_memory(self, memory_manager, mock_event_dispatcher):
        """Test recalling a memory."""
        # Arrange
        memory = Memory(
            owner_id="test_entity",
            content="Memory to recall",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.7,
        )
        await memory_manager.add_memory(memory)

        # Act
        recalled_memory = await memory_manager.recall_memory(
            memory.id, context="test context"
        )

        # Assert
        assert recalled_memory is not None
        assert recalled_memory.id == memory.id
        assert recalled_memory.recall_count > 0
        assert recalled_memory.last_recalled is not None

    @pytest.mark.asyncio
    async def test_event_dispatcher_integration(
        self, memory_manager, mock_event_dispatcher
    ):
        """Test that event dispatcher integration works correctly."""
        # Test that the memory manager has an event dispatcher
        assert memory_manager.event_dispatcher is not None

        # Test that creating a memory emits an event
        memory = await memory_manager.create_memory(
            content="Test memory for events", importance=0.7
        )

        # Verify at least one event was published
        assert mock_event_dispatcher.publish.called

    @pytest.mark.asyncio
    async def test_load_memories(self, memory_manager, mock_storage):
        """Test loading memories from storage."""
        # Arrange
        entity_id = "test_entity"
        memory_data = {
            "memory1": {
                "id": "memory1",
                "owner_id": entity_id,
                "content": "Stored memory 1",
                "memory_type": MemoryType.EXPERIENCE.name,
                "importance": 0.7,
                "entities_involved": [],
                "tags": [],
                "categories": [],
                "summary": "",
                "emotional_valence": MemoryEmotionalValence.NEUTRAL.name,
                "timestamp": time.time(),
                "created_at": "2024-01-01T00:00:00Z",
                "location": None,
                "metadata": {},
                "last_recalled": time.time(),
                "recall_count": 0,
                "access_count": 0,
                "last_accessed": None,
                "formation_strength": 1.0,
                "current_strength": 1.0,
                "links": {},
                "saliency": 0.7,
            },
            "memory2": {
                "id": "memory2",
                "owner_id": entity_id,
                "content": "Stored memory 2",
                "memory_type": MemoryType.EXPERIENCE.name,
                "importance": 0.5,
                "entities_involved": [],
                "tags": [],
                "categories": [],
                "summary": "",
                "emotional_valence": MemoryEmotionalValence.NEUTRAL.name,
                "timestamp": time.time(),
                "created_at": "2024-01-01T00:00:00Z",
                "location": None,
                "metadata": {},
                "last_recalled": time.time(),
                "recall_count": 0,
                "access_count": 0,
                "last_accessed": None,
                "formation_strength": 1.0,
                "current_strength": 1.0,
                "links": {},
                "saliency": 0.5,
            },
        }

        # Set up the mock to return our test data
        mock_storage.get_memories.return_value = memory_data

        # Act
        await memory_manager._load_memories()

        # Assert
        assert len(memory_manager.memories) == 2
        assert "memory1" in memory_manager.memories
        assert "memory2" in memory_manager.memories

        # Verify storage.get_memories was called with the right key
        # Note: get_memories is called twice - once during initialization and once explicitly
        assert mock_storage.get_memories.call_count == 2
        mock_storage.get_memories.assert_called_with(entity_id)

    @pytest.mark.asyncio
    async def test_save_memory(self, memory_manager, mock_storage):
        """Test saving a memory to storage."""
        # Arrange
        entity_id = "test_entity"
        memory = Memory(
            owner_id=entity_id,
            content="Memory to save",
            memory_type=MemoryType.EXPERIENCE,
            importance=0.6,
        )

        # Act
        await memory_manager._save_memory(memory)

        # Assert - verify storage.save_memory was called with the right data
        mock_storage.save_memory.assert_called_once()
        args = mock_storage.save_memory.call_args[0]

        # Args should be entity_id, memory_id, memory_dict
        assert args[0] == entity_id
        assert args[1] == memory.id

        # Third arg should be the serialized memory
        # Just check a few key properties to verify it's the right memory
        assert isinstance(args[2], dict)
        assert args[2]["owner_id"] == entity_id
        assert args[2]["content"] == "Memory to save"
