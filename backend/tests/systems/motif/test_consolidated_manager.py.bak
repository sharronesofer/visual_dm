#!/usr/bin/env python3
"""
Test Consolidated Motif Manager
===============================

Tests for the consolidated MotifManager implementation to verify it works
with both legacy API patterns and provides the expected functionality.

This test can be run with:
    pytest -xvs backend/systems/motif/tests/test_consolidated_manager.py
"""
import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch
import uuid
from datetime import datetime, timedelta

# Import the motif system modules
from backend.systems.motif import MotifManager, Motif, MotifCategory, MotifScope
from backend.systems.motif import MotifCreate, MotifUpdate, MotifFilter, MotifLifecycle


# Create a mock service for testing
class MockMotifService:
    """Mock service layer for testing the manager without database access"""

    def __init__(self):
        self.motifs = {}

    async def create_motif(self, motif_data):
        """Create a mock motif"""
        motif_id = str(uuid.uuid4())
        now = datetime.utcnow()

        # Create a motif from the data
        motif_dict = {
            "id": motif_id,
            "created_at": now,
            "updated_at": now,
            "lifecycle": MotifLifecycle.ACTIVE,
            "trigger_count": 0,
            "world_id": getattr(motif_data, "world_id", None),
        }

        # Add all attributes from the motif_data
        for attr in dir(motif_data):
            if not attr.startswith("_") and attr not in ["dict", "json"]:
                motif_dict[attr] = getattr(motif_data, attr)

        # Create the Motif object
        motif = Motif(**motif_dict)
        self.motifs[motif_id] = motif

        return motif

    async def get_motifs(self, filter_params=None):
        """Get motifs with optional filtering"""
        motifs = list(self.motifs.values())

        # No filtering
        if filter_params is None:
            return motifs

        # Apply filters
        filtered_motifs = []
        for motif in motifs:
            include = True

            # Filter by world_id
            if (
                hasattr(filter_params, "world_id")
                and filter_params.world_id is not None
            ):
                if getattr(motif, "world_id", None) != filter_params.world_id:
                    include = False

            # Filter by category
            if (
                hasattr(filter_params, "category")
                and filter_params.category is not None
            ):
                if getattr(motif, "category", None) != filter_params.category:
                    include = False

            # Filter by min_intensity
            if (
                hasattr(filter_params, "min_intensity")
                and filter_params.min_intensity is not None
            ):
                if getattr(motif, "intensity", 0) < filter_params.min_intensity:
                    include = False

            # Filter by tags
            if hasattr(filter_params, "tags") and filter_params.tags:
                if not any(
                    tag in getattr(motif, "tags", []) for tag in filter_params.tags
                ):
                    include = False

            if include:
                filtered_motifs.append(motif)

        return filtered_motifs

    async def get_motif(self, motif_id):
        """Get a specific motif by ID"""
        return self.motifs.get(motif_id)

    async def update_motif(self, motif_id, update_data):
        """Update a motif"""
        motif = self.motifs.get(motif_id)
        if not motif:
            return None

        # Apply updates
        for attr in dir(update_data):
            if not attr.startswith("_") and attr not in ["dict", "json"]:
                value = getattr(update_data, attr)
                if value is not None:
                    setattr(motif, attr, value)

        # Update timestamp
        motif.updated_at = datetime.utcnow()

        return motif

    async def delete_motif(self, motif_id):
        """Delete a motif"""
        if motif_id in self.motifs:
            del self.motifs[motif_id]
            return True
        return False


@pytest.fixture
def mock_service():
    """Create a mock service for testing"""
    return MockMotifService()


@pytest.fixture
def manager(mock_service):
    """Create a manager with a mock service for testing"""
    manager = MotifManager.get_instance()

    # Replace the service with our mock
    manager.service = mock_service

    # Reset event listeners
    manager._event_listeners = []

    # Reset caches
    manager._active_motifs_cache = None
    manager._cache_timestamp = None
    if hasattr(manager, "_motif_cache"):
        manager._motif_cache = {}
    if hasattr(manager, "_recent_triggers"):
        manager._recent_triggers = {}

    return manager


@pytest.mark.asyncio
async def test_create_motif_original_api(manager):
    """Test creating a motif using the original API style"""
    # Create a motif using the original API style
    motif_data = {
        "name": "Test Motif",
        "description": "A test motif",
        "category": MotifCategory.CONFLICT,
        "scope": MotifScope.REGIONAL,
        "intensity": 5.0,
        "theme": "conflict",
    }

    motif = await manager.create_motif(motif_data)

    # Verify motif was created with expected values
    assert motif is not None
    assert motif.name == "Test Motif"
    assert motif.description == "A test motif"
    assert motif.category == MotifCategory.CONFLICT
    assert motif.scope == MotifScope.REGIONAL
    assert motif.intensity == 5.0
    assert motif.theme == "conflict"

    return motif


@pytest.mark.asyncio
async def test_create_motif_legacy_api(manager):
    """Test creating a motif using the legacy API style"""
    # Create a motif using the legacy API style
    world_id = "test-world-123"
    motif = await manager.create_motif(
        world_id=world_id,
        name="Legacy Motif",
        description="A legacy test motif",
        strength=7.5,  # Note: 'strength' instead of 'intensity'
        tags=["test", "legacy"],
    )

    # Verify motif was created with expected values
    assert motif is not None
    assert motif.name == "Legacy Motif"
    assert motif.description == "A legacy test motif"
    assert motif.intensity == 7.5  # Should be mapped from 'strength'
    assert motif.world_id == world_id
    assert "test" in motif.tags
    assert "legacy" in motif.tags

    return motif


@pytest.mark.asyncio
async def test_get_motifs(manager):
    """Test getting motifs with different API styles"""
    # Create test motifs with both API styles
    motif1 = await test_create_motif_original_api(manager)
    motif2 = await test_create_motif_legacy_api(manager)

    # Test getting all motifs (original API)
    all_motifs = await manager.get_motifs()
    assert len(all_motifs) == 2

    # Test filtering by category (original API)
    conflict_motifs = await manager.get_motifs(
        MotifFilter(category=MotifCategory.CONFLICT)
    )
    assert len(conflict_motifs) == 1
    assert conflict_motifs[0].id == motif1.id

    # Test filtering by world (legacy API)
    world_motifs = await manager.get_motifs(world_id="test-world-123")
    assert len(world_motifs) == 1
    assert world_motifs[0].id == motif2.id

    # Test filtering by tag (legacy API)
    tag_motifs = await manager.get_motifs(tag="legacy")
    assert len(tag_motifs) == 1
    assert tag_motifs[0].id == motif2.id

    # Test filtering by strength (legacy API)
    strong_motifs = await manager.get_motifs(min_strength=6.0)
    assert len(strong_motifs) == 1
    assert strong_motifs[0].id == motif2.id


@pytest.mark.asyncio
async def test_get_motif(manager):
    """Test getting a specific motif with different API styles"""
    # Create test motifs with both API styles
    motif1 = await test_create_motif_original_api(manager)
    motif2 = await test_create_motif_legacy_api(manager)

    # Test getting motif with original API
    retrieved1 = await manager.get_motif(motif1.id)
    assert retrieved1 is not None
    assert retrieved1.id == motif1.id
    assert retrieved1.name == motif1.name

    # Test getting motif with legacy API (with world_id)
    retrieved2 = await manager.get_motif(motif2.id, world_id="test-world-123")
    assert retrieved2 is not None
    assert retrieved2.id == motif2.id
    assert retrieved2.name == motif2.name

    # Test getting motif with wrong world_id (should return None)
    retrieved_wrong = await manager.get_motif(motif2.id, world_id="wrong-world")
    assert retrieved_wrong is None


@pytest.mark.asyncio
async def test_update_motif(manager):
    """Test updating a motif with different API styles"""
    # Create test motifs with both API styles
    motif1 = await test_create_motif_original_api(manager)
    motif2 = await test_create_motif_legacy_api(manager)

    # Test updating with original API
    update_data = {"description": "Updated description", "intensity": 6.0}
    updated1 = await manager.update_motif(motif1.id, update_data)
    assert updated1.description == "Updated description"
    assert updated1.intensity == 6.0

    # Test updating with legacy API (strength update)
    updated2 = await manager.update_motif_strength(
        motif_id=motif2.id,
        world_id="test-world-123",
        new_strength=8.5,
        reason="Test update",
    )
    assert updated2 is not None
    assert updated2.intensity == 8.5
    # Verify the metadata was updated with reason
    assert "strength_history" in updated2.metadata
    assert len(updated2.metadata["strength_history"]) == 1
    assert updated2.metadata["strength_history"][0]["reason"] == "Test update"


@pytest.mark.asyncio
async def test_delete_motif(manager):
    """Test deleting a motif with different API styles"""
    # Create test motifs with both API styles
    motif1 = await test_create_motif_original_api(manager)
    motif2 = await test_create_motif_legacy_api(manager)

    # Test deleting with original API
    result1 = await manager.delete_motif(motif1.id)
    assert result1 is True

    # Verify motif1 is deleted
    retrieved1 = await manager.get_motif(motif1.id)
    assert retrieved1 is None

    # Test deleting with legacy API
    result2 = await manager.delete_motif(motif2.id, world_id="test-world-123")
    assert result2 is True

    # Verify motif2 is deleted
    retrieved2 = await manager.get_motif(motif2.id)
    assert retrieved2 is None


@pytest.mark.asyncio
async def test_trigger_motif(manager):
    """Test triggering a motif (legacy API feature)"""
    # Create a test motif
    motif = await test_create_motif_legacy_api(manager)

    # Initial values
    initial_intensity = motif.intensity
    initial_trigger_count = getattr(motif, "trigger_count", 0)

    # Trigger the motif
    triggered_motif = await manager.trigger_motif(
        motif_id=motif.id,
        context="Test trigger context",
        world_id="test-world-123",
        character_ids=["character-1", "character-2"],
        location_id="location-1",
        trigger_strength=2.0,
    )

    # Verify the trigger effects
    assert triggered_motif is not None
    assert triggered_motif.intensity > initial_intensity
    assert triggered_motif.trigger_count == initial_trigger_count + 1
    assert triggered_motif.last_triggered is not None

    # Verify trigger history in metadata
    assert "trigger_history" in triggered_motif.metadata
    assert len(triggered_motif.metadata["trigger_history"]) == 1
    assert (
        triggered_motif.metadata["trigger_history"][0]["context"]
        == "Test trigger context"
    )

    # Verify recent triggers were stored
    assert hasattr(manager, "_recent_triggers")
    assert "test-world-123" in manager._recent_triggers
    assert len(manager._recent_triggers["test-world-123"]) == 1
    assert (
        manager._recent_triggers["test-world-123"][0].context == "Test trigger context"
    )


if __name__ == "__main__":
    # Allow running directly as a script
    pytest.main(["-xvs", __file__])
