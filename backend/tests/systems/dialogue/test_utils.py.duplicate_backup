"""
Tests for backend.systems.dialogue.utils

Comprehensive tests for dialogue utility functions.
"""

import pytest
from unittest.mock import patch
from datetime import datetime

# Import the module being tested
try:
    from backend.systems.dialogue.utils import (
        count_tokens,
        relevance_score,
        extract_key_info,
        clean_text_for_dialogue,
        get_dialogue_keywords,
        sentiment_analysis,
        KEYWORDS
    )
except ImportError as e:
    pytest.skip(f"Could not import dialogue utils: {e}", allow_module_level=True)


class TestCountTokens:
    """Test token counting functionality."""
    
    def test_count_tokens_empty_string(self):
        """Test token counting with empty string."""
        assert count_tokens("") == 0
        assert count_tokens(None) == 0
    
    def test_count_tokens_simple_text(self):
        """Test token counting with simple text."""
        text = "Hello world"
        tokens = count_tokens(text)
        # 2 words + 0 punctuation + 2 special tokens = 4
        assert tokens == 4
    
    def test_count_tokens_with_punctuation(self):
        """Test token counting with punctuation."""
        text = "Hello, world! How are you?"
        tokens = count_tokens(text)
        # 5 words + 3 punctuation (,!?) + 2 special tokens = 10
        assert tokens == 10
    
    def test_count_tokens_complex_text(self):
        """Test token counting with complex text."""
        text = "The quick brown fox jumps over the lazy dog."
        tokens = count_tokens(text)
        # 9 words + 1 punctuation (.) + 2 special tokens = 12
        assert tokens == 12


class TestRelevanceScore:
    """Test relevance scoring functionality."""
    
    def test_relevance_score_empty_inputs(self):
        """Test relevance score with empty inputs."""
        assert relevance_score("", "query") == 0.0
        assert relevance_score("text", "") == 0.0
        assert relevance_score("", "") == 0.0
        assert relevance_score(None, "query") == 0.0
        assert relevance_score("text", None) == 0.0
    
    def test_relevance_score_exact_match(self):
        """Test relevance score with exact word matches."""
        text = "The quick brown fox"
        query = "fox"
        score = relevance_score(text, query)
        # 1 matching word out of 1 query word = 1.0 * 0.5 = 0.5
        assert score == 0.5
    
    def test_relevance_score_partial_match(self):
        """Test relevance score with partial matches."""
        text = "The quick brown fox jumps"
        query = "fox wolf"
        score = relevance_score(text, query)
        # 1 matching word out of 2 query words = 0.5 * 0.5 = 0.25
        assert score == 0.25
    
    def test_relevance_score_phrase_match(self):
        """Test relevance score with exact phrase matches."""
        text = "The quick brown fox jumps over the lazy dog"
        query = "brown fox"
        score = relevance_score(text, query)
        # Should have phrase bonus: word overlap + phrase bonus
        assert score > 0.5  # Should be higher due to phrase match
    
    def test_relevance_score_case_sensitivity(self):
        """Test relevance score case sensitivity."""
        text = "The QUICK Brown Fox"
        query = "quick brown"
        
        # Case insensitive (default)
        score_insensitive = relevance_score(text, query, case_sensitive=False)
        assert score_insensitive > 0.0
        
        # Case sensitive
        score_sensitive = relevance_score(text, query, case_sensitive=True)
        assert score_sensitive < score_insensitive
    
    def test_relevance_score_no_match(self):
        """Test relevance score with no matches."""
        text = "The quick brown fox"
        query = "elephant tiger"
        score = relevance_score(text, query)
        assert score == 0.0


class TestExtractKeyInfo:
    """Test key information extraction functionality."""
    
    def test_extract_key_info_empty_text(self):
        """Test extraction with empty text."""
        assert extract_key_info("") == []
        assert extract_key_info(None) == []
    
    def test_extract_key_info_quest_keywords(self):
        """Test extraction of quest-related information."""
        text = "I have a quest for you to complete in the dungeon."
        info = extract_key_info(text)
        
        # Should find quest and location keywords
        quest_items = [item for item in info if item["category"] == "quest"]
        location_items = [item for item in info if item["category"] == "location"]
        
        assert len(quest_items) > 0
        assert len(location_items) > 0
        assert quest_items[0]["keyword"] == "quest"
        assert location_items[0]["keyword"] == "dungeon"
    
    def test_extract_key_info_person_keywords(self):
        """Test extraction of person-related information."""
        text = "The merchant told me about a powerful mage in the village."
        info = extract_key_info(text)
        
        person_items = [item for item in info if item["category"] == "person"]
        location_items = [item for item in info if item["category"] == "location"]
        
        assert len(person_items) >= 2  # merchant and mage
        assert len(location_items) > 0  # village
    
    def test_extract_key_info_item_keywords(self):
        """Test extraction of item-related information."""
        text = "I found a magical sword and some potions in the treasure chest."
        info = extract_key_info(text)
        
        item_items = [item for item in info if item["category"] == "item"]
        
        assert len(item_items) >= 2  # potions, treasure (sword not in KEYWORDS)
        item_keywords = [item["keyword"] for item in item_items]
        assert "potion" in item_keywords
        assert "treasure" in item_keywords
    
    def test_extract_key_info_context_preservation(self):
        """Test that context sentences are preserved."""
        text = "The dragon guards the treasure. The village needs help."
        info = extract_key_info(text)
        
        # Check that each extracted item has proper context
        for item in info:
            assert "context" in item
            assert "timestamp" in item
            assert len(item["context"]) > 0
    
    def test_extract_key_info_multiple_categories(self):
        """Test extraction with multiple categories in one text."""
        text = "The king needs a hero to defeat the dragon and save the kingdom."
        info = extract_key_info(text)
        
        categories = {item["category"] for item in info}
        # Should find person (king), enemy (dragon), faction (kingdom)
        assert "person" in categories
        assert "enemy" in categories


class TestCleanTextForDialogue:
    """Test text cleaning functionality."""
    
    def test_clean_text_empty_string(self):
        """Test cleaning empty string."""
        assert clean_text_for_dialogue("") == ""
        assert clean_text_for_dialogue(None) == ""
    
    def test_clean_text_excessive_whitespace(self):
        """Test removal of excessive whitespace."""
        text = "Hello    world   with   spaces"
        cleaned = clean_text_for_dialogue(text)
        assert cleaned == "Hello world with spaces"
    
    def test_clean_text_punctuation_spacing(self):
        """Test fixing punctuation spacing."""
        text = "Hello , world ! How are you ?"
        cleaned = clean_text_for_dialogue(text)
        assert cleaned == "Hello, world! How are you?"
    
    def test_clean_text_quote_normalization(self):
        """Test quote normalization."""
        text = 'He said "Hello" and \'goodbye\''
        cleaned = clean_text_for_dialogue(text)
        assert cleaned == 'He said "Hello" and \'goodbye\''
    
    def test_clean_text_bracket_spacing(self):
        """Test bracket spacing normalization."""
        text = "Items: [ sword , shield ]"
        cleaned = clean_text_for_dialogue(text)
        assert cleaned == "Items: [sword, shield ]"  # Current implementation behavior
    
    def test_clean_text_trim_whitespace(self):
        """Test trimming leading/trailing whitespace."""
        text = "   Hello world   "
        cleaned = clean_text_for_dialogue(text)
        assert cleaned == "Hello world"


class TestGetDialogueKeywords:
    """Test dialogue keyword extraction functionality."""
    
    def test_get_dialogue_keywords_empty_text(self):
        """Test keyword extraction with empty text."""
        assert get_dialogue_keywords("") == []
        assert get_dialogue_keywords(None) == []
    
    def test_get_dialogue_keywords_simple_text(self):
        """Test keyword extraction with simple text."""
        text = "The dragon attacked the village and destroyed many houses"
        keywords = get_dialogue_keywords(text)
        
        # Should extract meaningful words, excluding stopwords
        assert len(keywords) <= 5  # Default max_keywords
        assert "dragon" in keywords
        assert "village" in keywords
        assert "attacked" in keywords or "destroyed" in keywords
        
        # Should not contain stopwords
        assert "the" not in keywords
        assert "and" not in keywords
    
    def test_get_dialogue_keywords_max_limit(self):
        """Test keyword extraction with max limit."""
        text = "The brave knight fought the terrible dragon in the ancient castle while the villagers watched from the safety of their homes"
        keywords = get_dialogue_keywords(text, max_keywords=3)
        
        assert len(keywords) <= 3
        assert len(keywords) > 0
    
    def test_get_dialogue_keywords_word_frequency(self):
        """Test that more frequent words are prioritized."""
        text = "dragon dragon dragon knight knight wizard"
        keywords = get_dialogue_keywords(text, max_keywords=5)
        
        # "dragon" appears 3 times, should be first
        assert keywords[0] == "dragon"
        assert "knight" in keywords
        assert "wizard" in keywords
    
    def test_get_dialogue_keywords_short_words_filtered(self):
        """Test that short words are filtered out."""
        text = "I am go to be at it on up we"
        keywords = get_dialogue_keywords(text)
        
        # All words are either stopwords or too short (≤2 chars)
        assert len(keywords) == 0


class TestSentimentAnalysis:
    """Test sentiment analysis functionality."""
    
    def test_sentiment_analysis_empty_text(self):
        """Test sentiment analysis with empty text."""
        result = sentiment_analysis("")
        assert result == {"positive": 0.0, "negative": 0.0, "neutral": 1.0}
        
        result = sentiment_analysis(None)
        assert result == {"positive": 0.0, "negative": 0.0, "neutral": 1.0}
    
    def test_sentiment_analysis_positive_text(self):
        """Test sentiment analysis with positive text."""
        text = "This is a great and wonderful day! I love it!"
        result = sentiment_analysis(text)
        
        assert result["positive"] > 0.0
        assert result["positive"] > result["negative"]
        assert "positive" in result
        assert "negative" in result
        assert "neutral" in result
        
        # Scores should sum to approximately 1.0 (allowing for floating point precision)
        total = result["positive"] + result["negative"] + result["neutral"]
        assert abs(total - 1.0) < 0.01
    
    def test_sentiment_analysis_negative_text(self):
        """Test sentiment analysis with negative text."""
        text = "This is terrible and awful! I hate it!"
        result = sentiment_analysis(text)
        
        assert result["negative"] > 0.0
        assert result["negative"] > result["positive"]
    
    def test_sentiment_analysis_neutral_text(self):
        """Test sentiment analysis with neutral text."""
        text = "The table is made of wood and has four legs."
        result = sentiment_analysis(text)
        
        assert result["neutral"] > result["positive"]
        assert result["neutral"] > result["negative"]
    
    def test_sentiment_analysis_mixed_text(self):
        """Test sentiment analysis with mixed sentiment."""
        text = "I love the good parts but hate the bad terrible aspects."
        result = sentiment_analysis(text)
        
        assert result["positive"] > 0.0
        assert result["negative"] > 0.0
        
        # Should have both positive and negative sentiment
        total_sentiment = result["positive"] + result["negative"]
        assert total_sentiment > 0.0
    
    def test_sentiment_analysis_score_bounds(self):
        """Test that sentiment scores are properly bounded."""
        text = "amazing wonderful excellent fantastic perfect brilliant awesome"
        result = sentiment_analysis(text)
        
        # All scores should be between 0 and 1
        assert 0.0 <= result["positive"] <= 1.0
        assert 0.0 <= result["negative"] <= 1.0
        assert 0.0 <= result["neutral"] <= 1.0


class TestKeywordsConstant:
    """Test the KEYWORDS constant."""
    
    def test_keywords_structure(self):
        """Test that KEYWORDS has the expected structure."""
        assert isinstance(KEYWORDS, dict)
        
        expected_categories = ["quest", "location", "person", "item", "enemy", "faction"]
        for category in expected_categories:
            assert category in KEYWORDS
            assert isinstance(KEYWORDS[category], list)
            assert len(KEYWORDS[category]) > 0
    
    def test_keywords_content(self):
        """Test that KEYWORDS contains expected content."""
        # Check some expected keywords exist
        assert "quest" in KEYWORDS["quest"]
        assert "city" in KEYWORDS["location"]
        assert "npc" in KEYWORDS["person"]
        assert "weapon" in KEYWORDS["item"]
        assert "dragon" in KEYWORDS["enemy"]
        assert "guild" in KEYWORDS["faction"] 