"""
Tests for backend.systems.world_state.integration.event_integration

Comprehensive tests for the event integration functionality.
"""

import pytest
from datetime import datetime
from unittest.mock import Mock, patch, MagicMock
from typing import Dict, Any, List

# Import the module being tested
try:
    from backend.systems.world_state.integration.event_integration import (
        WorldStateEventIntegration, StateChangeEvent, StateCreateEvent, 
        StateDeleteEvent, StateQueryEvent, StateBulkChangeEvent, 
        StateTimelineEvent
    )
    from backend.systems.world_state.consolidated_state_models import (
        StateVariable, StateChangeRecord, StateCategory, WorldRegion,
        StateChangeType, WorldStateSnapshot
    )
    from backend.systems.world_state.consolidated_world_models import (
        WorldStateCreatedEvent, WorldStateUpdatedEvent, WorldStateDeletedEvent
    )
except ImportError as e:
    pytest.skip(f"Could not import backend.systems.world_state.integration.event_integration: {e}", allow_module_level=True)


class TestStateChangeEvent:
    """Test StateChangeEvent class."""

    def test_init_basic(self):
        """Test basic StateChangeEvent initialization."""
        event = StateChangeEvent("test_key", "test_value")
        
        assert event.key == "test_key"
        assert event.value == "test_value"
        assert event.category == "OTHER"
        assert event.region == "GLOBAL"
        assert event.tags == []
        assert event.entity_id is None
        assert event.result is None

    def test_init_with_all_params(self):
        """Test StateChangeEvent with all parameters."""
        event = StateChangeEvent(
            key="complex_key",
            value={"data": "complex"},
            category="COMBAT",
            region="CITY_CENTER",
            tags=["tag1", "tag2"],
            entity_id="entity_123"
        )
        
        assert event.key == "complex_key"
        assert event.value == {"data": "complex"}
        assert event.category == "COMBAT"
        assert event.region == "CITY_CENTER"
        assert event.tags == ["tag1", "tag2"]
        assert event.entity_id == "entity_123"
        assert event.result is None


class TestStateCreateEvent:
    """Test StateCreateEvent class."""

    def test_inheritance(self):
        """Test that StateCreateEvent inherits from StateChangeEvent."""
        event = StateCreateEvent("create_key", "create_value")
        
        assert isinstance(event, StateChangeEvent)
        assert event.key == "create_key"
        assert event.value == "create_value"


class TestStateDeleteEvent:
    """Test StateDeleteEvent class."""

    def test_init_basic(self):
        """Test basic StateDeleteEvent initialization."""
        event = StateDeleteEvent("delete_key")
        
        assert event.key == "delete_key"
        assert event.entity_id is None
        assert event.result is None

    def test_init_with_entity_id(self):
        """Test StateDeleteEvent with entity ID."""
        event = StateDeleteEvent("delete_key", "entity_456")
        
        assert event.key == "delete_key"
        assert event.entity_id == "entity_456"
        assert event.result is None


class TestStateQueryEvent:
    """Test StateQueryEvent class."""

    def test_init(self):
        """Test StateQueryEvent initialization."""
        event = StateQueryEvent("key", "search_value")
        
        assert event.query_type == "key"
        assert event.query_value == "search_value"
        assert event.results is None

    def test_init_different_types(self):
        """Test StateQueryEvent with different query types."""
        query_types = ["category", "region", "prefix", "tags"]
        for query_type in query_types:
            event = StateQueryEvent(query_type, f"value_{query_type}")
            assert event.query_type == query_type
            assert event.query_value == f"value_{query_type}"


class TestStateBulkChangeEvent:
    """Test StateBulkChangeEvent class."""

    def test_init(self):
        """Test StateBulkChangeEvent initialization."""
        changes = [
            StateChangeEvent("key1", "value1"),
            StateChangeEvent("key2", "value2")
        ]
        event = StateBulkChangeEvent(changes)
        
        assert event.changes == changes
        assert event.results == []

    def test_init_empty(self):
        """Test StateBulkChangeEvent with empty changes."""
        event = StateBulkChangeEvent([])
        
        assert event.changes == []
        assert event.results == []


class TestStateTimelineEvent:
    """Test StateTimelineEvent class."""

    def test_init_time_query(self):
        """Test StateTimelineEvent with time query."""
        timestamp = datetime.now()
        event = StateTimelineEvent("time", "test_key", timestamp)
        
        assert event.query_type == "time"
        assert event.key == "test_key"
        assert event.query_value == timestamp
        assert event.result is None

    def test_init_version_query(self):
        """Test StateTimelineEvent with version query."""
        event = StateTimelineEvent("version", "test_key", 42)
        
        assert event.query_type == "version"
        assert event.key == "test_key"
        assert event.query_value == 42
        assert event.result is None


class TestWorldStateEventIntegration:
    """Test WorldStateEventIntegration class."""

    def setup_method(self):
        """Set up test fixtures."""
        # Reset singleton instance
        WorldStateEventIntegration._instance = None

    def teardown_method(self):
        """Clean up after tests."""
        # Reset singleton instance
        WorldStateEventIntegration._instance = None

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_singleton_pattern(self, mock_manager, mock_dispatcher):
        """Test singleton pattern implementation."""
        instance1 = WorldStateEventIntegration.get_instance()
        instance2 = WorldStateEventIntegration.get_instance()
        
        assert instance1 is instance2
        assert WorldStateEventIntegration._instance is instance1

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_init_direct_creation_fails(self, mock_manager, mock_dispatcher):
        """Test that direct instantiation after singleton creation fails."""
        WorldStateEventIntegration.get_instance()
        
        with pytest.raises(RuntimeError, match="WorldStateEventIntegration is a singleton"):
            WorldStateEventIntegration()

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_initialization(self, mock_manager, mock_dispatcher):
        """Test initialization process."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        assert integration.event_dispatcher == mock_dispatcher_instance
        assert integration.world_state_manager == mock_manager_instance
        assert not integration.initialized

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_initialize_once(self, mock_manager, mock_dispatcher):
        """Test that initialize only runs once."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        # First initialization
        integration.initialize()
        assert integration.initialized
        
        # Second initialization should not re-run
        subscribe_call_count = mock_dispatcher_instance.subscribe.call_count
        integration.initialize()
        assert mock_dispatcher_instance.subscribe.call_count == subscribe_call_count

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_register_event_handlers(self, mock_manager, mock_dispatcher):
        """Test event handler registration."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        integration.initialize()
        
        # Verify all handlers are registered
        expected_events = [
            "world_state.change",
            "world_state.create",
            "world_state.delete",
            "world_state.query",
            "world_state.bulk_change",
            "world_state.timeline"
        ]
        
        for event in expected_events:
            mock_dispatcher_instance.subscribe.assert_any_call(event, integration._handle_state_change if event == "world_state.change" else integration._handle_state_create if event == "world_state.create" else integration._handle_state_delete if event == "world_state.delete" else integration._handle_state_query if event == "world_state.query" else integration._handle_bulk_change if event == "world_state.bulk_change" else integration._handle_state_timeline)

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_change_success(self, mock_manager, mock_dispatcher):
        """Test successful state change handling."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        # Mock successful state update
        expected_result = {"success": True, "value": "test_value"}
        mock_manager_instance.set_state.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        # Create test event
        event = StateChangeEvent(
            key="test_key",
            value="test_value",
            category="COMBAT",
            region="CITY_CENTER",
            tags=["tag1"],
            entity_id="entity_123"
        )
        
        # Handle the event
        integration._handle_state_change(event)
        
        # Verify state was set correctly
        mock_manager_instance.set_state.assert_called_once()
        args, kwargs = mock_manager_instance.set_state.call_args
        assert kwargs['key'] == "test_key"
        assert kwargs['value'] == "test_value"
        assert kwargs['tags'] == ["tag1"]
        assert kwargs['entity_id'] == "entity_123"
        
        # Verify result was stored
        assert event.result == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_change_enum_conversion(self, mock_manager, mock_dispatcher):
        """Test state change with enum conversion."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        # Create event with string values that need enum conversion
        event = StateChangeEvent(
            key="test_key",
            value="test_value",
            category="other",  # lowercase
            region="global"    # lowercase
        )
        
        integration._handle_state_change(event)
        
        # Verify enums were used in the call
        mock_manager_instance.set_state.assert_called_once()
        args, kwargs = mock_manager_instance.set_state.call_args
        # The actual enum comparison would depend on implementation

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_change_error(self, mock_manager, mock_dispatcher):
        """Test state change handling with error."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        # Mock error during state update
        mock_manager_instance.set_state.side_effect = Exception("Test error")
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateChangeEvent("test_key", "test_value")
        
        # Should not raise exception
        integration._handle_state_change(event)
        
        # Result should be None on error
        assert event.result is None

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_create(self, mock_manager, mock_dispatcher):
        """Test state creation handling."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateCreateEvent("create_key", "create_value")
        
        # Since StateCreateEvent inherits from StateChangeEvent,
        # this should call the same handler
        integration._handle_state_create(event)
        
        # Should call set_state
        mock_manager_instance.set_state.assert_called_once()

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_delete_success(self, mock_manager, mock_dispatcher):
        """Test successful state deletion."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        expected_result = {"success": True, "deleted": True}
        mock_manager_instance.delete_state.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateDeleteEvent("delete_key", "entity_123")
        integration._handle_state_delete(event)
        
        mock_manager_instance.delete_state.assert_called_once_with(
            key="delete_key",
            entity_id="entity_123"
        )
        assert event.result == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_delete_error(self, mock_manager, mock_dispatcher):
        """Test state deletion with error."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        mock_manager_instance.delete_state.side_effect = Exception("Delete error")
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateDeleteEvent("delete_key")
        integration._handle_state_delete(event)
        
        assert event.result is None

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_query_by_key(self, mock_manager, mock_dispatcher):
        """Test state query by key."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        expected_result = [{"key": "test_key", "value": "test_value"}]
        mock_manager_instance.get_state.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateQueryEvent("key", "test_key")
        integration._handle_state_query(event)
        
        mock_manager_instance.get_state.assert_called_once_with("test_key")
        assert event.results == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_query_by_category(self, mock_manager, mock_dispatcher):
        """Test state query by category."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        expected_result = [{"category": "COMBAT"}]
        mock_manager_instance.get_states_by_category.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateQueryEvent("category", "COMBAT")
        integration._handle_state_query(event)
        
        mock_manager_instance.get_states_by_category.assert_called_once()
        assert event.results == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_bulk_change_success(self, mock_manager, mock_dispatcher):
        """Test successful bulk state changes."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        # Mock successful results for each change
        mock_manager_instance.set_state.side_effect = [
            {"success": True, "key": "key1"},
            {"success": True, "key": "key2"}
        ]
        
        integration = WorldStateEventIntegration.get_instance()
        
        changes = [
            StateChangeEvent("key1", "value1"),
            StateChangeEvent("key2", "value2")
        ]
        event = StateBulkChangeEvent(changes)
        
        integration._handle_bulk_change(event)
        
        assert len(event.results) == 2
        assert all(result["success"] for result in event.results)

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_timeline_by_time(self, mock_manager, mock_dispatcher):
        """Test state timeline query by time."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        timestamp = datetime.now()
        expected_result = {"key": "test_key", "value": "historical_value"}
        mock_manager_instance.get_state_at_time.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateTimelineEvent("time", "test_key", timestamp)
        integration._handle_state_timeline(event)
        
        mock_manager_instance.get_state_at_time.assert_called_once_with("test_key", timestamp)
        assert event.result == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_handle_state_timeline_by_version(self, mock_manager, mock_dispatcher):
        """Test state timeline query by version."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        expected_result = {"key": "test_key", "value": "versioned_value"}
        mock_manager_instance.get_state_at_version.return_value = expected_result
        
        integration = WorldStateEventIntegration.get_instance()
        
        event = StateTimelineEvent("version", "test_key", 42)
        integration._handle_state_timeline(event)
        
        mock_manager_instance.get_state_at_version.assert_called_once_with("test_key", 42)
        assert event.result == expected_result

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_publish_state_change(self, mock_manager, mock_dispatcher):
        """Test publishing state change events."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        # Create mock objects
        mock_variable = Mock()
        mock_variable.key = "test_key"
        mock_variable.value = "test_value"
        mock_variable.category = StateCategory.COMBAT
        
        integration.publish_state_change("test_key", mock_variable, StateChangeType.CREATED)
        
        # Verify event was published
        mock_dispatcher_instance.publish.assert_called_once()
        event_name, event_data = mock_dispatcher_instance.publish.call_args[0]
        assert event_name == "world_state.state_changed"

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_publish_state_version_created(self, mock_manager, mock_dispatcher):
        """Test publishing state version created events."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        integration.publish_state_version_created(42, 5, "2023-01-01T12:00:00Z")
        
        mock_dispatcher_instance.publish.assert_called_once()
        event_name, event_data = mock_dispatcher_instance.publish.call_args[0]
        assert event_name == "world_state.version_created"

    @patch('backend.systems.world_state.integration.event_integration.EventDispatcher')
    @patch('backend.systems.world_state.integration.event_integration.WorldStateManager')
    def test_publish_state_snapshot_created(self, mock_manager, mock_dispatcher):
        """Test publishing state snapshot created events."""
        mock_dispatcher_instance = Mock()
        mock_manager_instance = Mock()
        mock_dispatcher.get_instance.return_value = mock_dispatcher_instance
        mock_manager.get_instance.return_value = mock_manager_instance
        
        integration = WorldStateEventIntegration.get_instance()
        
        metadata = {"source": "test", "type": "manual"}
        integration.publish_state_snapshot_created(42, "2023-01-01T12:00:00Z", metadata)
        
        mock_dispatcher_instance.publish.assert_called_once()
        event_name, event_data = mock_dispatcher_instance.publish.call_args[0]
        assert event_name == "world_state.snapshot_created"


class TestEventIntegrationModuleFunctions:
    """Test module-level functions and constants."""

    def test_module_imports(self):
        """Test that all required imports are available."""
        from backend.systems.world_state.integration.event_integration import (
            WorldStateEventIntegration, StateChangeEvent, StateCreateEvent,
            StateDeleteEvent, StateQueryEvent, StateBulkChangeEvent,
            StateTimelineEvent
        )
        
        # Verify classes exist
        assert WorldStateEventIntegration is not None
        assert StateChangeEvent is not None
        assert StateCreateEvent is not None
        assert StateDeleteEvent is not None
        assert StateQueryEvent is not None
        assert StateBulkChangeEvent is not None
        assert StateTimelineEvent is not None 