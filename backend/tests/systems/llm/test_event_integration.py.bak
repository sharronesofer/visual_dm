"""
Integration tests for the LLM system's event-driven architecture.

These tests validate that the event-driven components work together correctly:
1. Event dispatcher properly routes events to subscribers
2. Middleware chain processes events correctly
3. Repositories handle data operations properly
4. Core components interact via events rather than direct calls
"""

import unittest
import os
import tempfile
import json
import shutil
from datetime import datetime
from unittest.mock import MagicMock, patch

from backend.systems.llm.core.event_integration import (
    EventDispatcher,
    EventBase,
    LoggingMiddleware,
    ValidationMiddleware,
    AnalyticsMiddleware,
    ThrottlingMiddleware,
    MiddlewareChain,
    MemoryEvent,
    RumorEvent,
    MotifEvent,
)
from backend.systems.llm.repositories.player_repository import PlayerRepository
from backend.systems.llm.repositories.region_repository import RegionRepository
from backend.systems.llm.repositories.npc_repository import NPCRepository
from backend.systems.llm.repositories.faction_repository import FactionRepository
from backend.systems.llm.repositories.world_repository import WorldRepository
from backend.systems.llm.repositories.motif_repository import MotifRepository
from backend.systems.llm.repositories.rumor_repository import RumorRepository
from backend.systems.llm.core.dm_core import (
    DungeonMaster,
    ContextRequest,
    ContextResponse,
)


class TestEventIntegration(unittest.TestCase):
    """Integration tests for the event-driven architecture of the LLM system."""

    def setUp(self):
        """Set up test environment with a temporary data directory."""
        # Create temporary data directory
        self.temp_dir = tempfile.mkdtemp()
        os.environ["VDM_DATA_DIR"] = self.temp_dir

        # Create necessary subdirectories
        os.makedirs(os.path.join(self.temp_dir, "entities", "players"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "entities", "npcs"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "entities", "factions"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "world", "regions"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "motifs"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "rumors"), exist_ok=True)

        # Reset all singleton instances
        EventDispatcher._instance = None
        PlayerRepository._instance = None
        RegionRepository._instance = None
        NPCRepository._instance = None
        FactionRepository._instance = None
        WorldRepository._instance = None
        MotifRepository._instance = None
        RumorRepository._instance = None
        DungeonMaster._instance = None

        # Get clean instances
        self.event_dispatcher = EventDispatcher.get_instance()
        self.player_repo = PlayerRepository.get_instance()
        self.region_repo = RegionRepository.get_instance()
        self.npc_repo = NPCRepository.get_instance()
        self.faction_repo = FactionRepository.get_instance()
        self.world_repo = WorldRepository.get_instance()
        self.motif_repo = MotifRepository.get_instance()
        self.rumor_repo = RumorRepository.get_instance()

        # Create some test data
        self._create_test_data()

    def tearDown(self):
        """Clean up the test environment."""
        shutil.rmtree(self.temp_dir)

    def _create_test_data(self):
        """Create test data for repositories."""
        # Create a test player
        player_data = {
            "id": "test_player",
            "name": "Test Player",
            "region_id": "test_region",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "motifs": {
                "active": [
                    {
                        "theme": "vengeance",
                        "weight": 5,
                        "added_at": datetime.utcnow().isoformat(),
                    }
                ],
                "expired": [],
            },
            "relationships": {
                "npc": {
                    "test_npc": {
                        "standing": 0.7,
                        "reputation": 0.5,
                        "updated_at": datetime.utcnow().isoformat(),
                    }
                },
                "faction": {
                    "test_faction": {
                        "standing": 0.3,
                        "reputation": 0.2,
                        "updated_at": datetime.utcnow().isoformat(),
                    }
                },
            },
        }
        self.player_repo.update_player_data("test_player", player_data)

        # Create a test NPC
        npc_data = {
            "id": "test_npc",
            "name": "Test NPC",
            "region_id": "test_region",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "motifs": {
                "active": [
                    {
                        "theme": "betrayal",
                        "weight": 3,
                        "added_at": datetime.utcnow().isoformat(),
                    }
                ],
                "expired": [],
            },
            "faction_affiliations": [{"id": "test_faction", "loyalty": 2}],
        }
        self.npc_repo.update_npc_data("test_npc", npc_data)

        # Create a test faction
        faction_data = {
            "id": "test_faction",
            "name": "Test Faction",
            "description": "A faction for testing",
            "type": "political",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "regions": ["test_region"],
            "power_level": 5,
            "stability": 0.8,
        }
        self.faction_repo.update_faction_data("test_faction", faction_data)

        # Create a test region
        region_data = {
            "id": "test_region",
            "name": "Test Region",
            "description": "A region for testing",
            "biome": "forest",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "tension": {"level": 3, "label": "moderate"},
        }
        self.region_repo.update_region_data("test_region", region_data)

        # Create a test motif
        motif_data = {
            "id": "test_motif",
            "name": "Test Motif",
            "description": "A motif for testing",
            "category": "betrayal",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "intensity": 4,
            "associated_emotions": ["anger", "sadness"],
        }
        self.motif_repo.update_motif_data("test_motif", motif_data)

        # Create a test rumor
        rumor_data = {
            "id": "test_rumor",
            "content": "A test rumor about a hidden treasure",
            "rumor_type": "treasure",
            "source_entity_id": "test_npc",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "truth_value": 0.7,
            "severity": 2,
            "region_id": "test_region",
        }
        self.rumor_repo.update_rumor_data("test_rumor", rumor_data)

    def test_event_dispatcher_singleton(self):
        """Test that EventDispatcher behaves as a singleton."""
        dispatcher1 = EventDispatcher.get_instance()
        dispatcher2 = EventDispatcher.get_instance()
        self.assertIs(dispatcher1, dispatcher2)

    def test_repository_singletons(self):
        """Test that all repositories behave as singletons."""
        player_repo1 = PlayerRepository.get_instance()
        player_repo2 = PlayerRepository.get_instance()
        self.assertIs(player_repo1, player_repo2)

        region_repo1 = RegionRepository.get_instance()
        region_repo2 = RegionRepository.get_instance()
        self.assertIs(region_repo1, region_repo2)

        npc_repo1 = NPCRepository.get_instance()
        npc_repo2 = NPCRepository.get_instance()
        self.assertIs(npc_repo1, npc_repo2)

        faction_repo1 = FactionRepository.get_instance()
        faction_repo2 = FactionRepository.get_instance()
        self.assertIs(faction_repo1, faction_repo2)

        world_repo1 = WorldRepository.get_instance()
        world_repo2 = WorldRepository.get_instance()
        self.assertIs(world_repo1, world_repo2)

        motif_repo1 = MotifRepository.get_instance()
        motif_repo2 = MotifRepository.get_instance()
        self.assertIs(motif_repo1, motif_repo2)

        rumor_repo1 = RumorRepository.get_instance()
        rumor_repo2 = RumorRepository.get_instance()
        self.assertIs(rumor_repo1, rumor_repo2)

    def test_middleware_chain(self):
        """Test that the middleware chain processes events correctly."""

        # Create a custom event
        class TestEvent(EventBase):
            event_type: str = "test.event"
            data: str

        # Create a mock middleware
        mock_middleware = MagicMock()
        mock_middleware.process.return_value = TestEvent(data="processed")

        # Add the mock middleware to the chain
        self.event_dispatcher.add_middleware(mock_middleware)

        # Create a mock handler
        mock_handler = MagicMock()

        # Subscribe the mock handler to the event
        self.event_dispatcher.subscribe("test.event", mock_handler)

        # Publish the event
        self.event_dispatcher.publish_sync(TestEvent(data="original"))

        # Check that the middleware was called
        mock_middleware.process.assert_called_once()

        # Check that the handler was called with the processed event
        self.assertEqual(mock_handler.call_count, 1)
        called_event = mock_handler.call_args[0][0]
        self.assertEqual(called_event.data, "processed")

        # Clean up
        self.event_dispatcher.remove_middleware(mock_middleware)

    def test_event_subscription_and_publishing(self):
        """Test that events are correctly dispatched to subscribers."""

        # Create a test event class
        class TestEvent(EventBase):
            event_type: str = "test.event"
            message: str

        # Create mock handlers
        handler1 = MagicMock()
        handler2 = MagicMock()

        # Subscribe handlers to the event
        self.event_dispatcher.subscribe("test.event", handler1)
        self.event_dispatcher.subscribe(TestEvent, handler2)

        # Publish an event
        event = TestEvent(message="Hello, world!")
        self.event_dispatcher.publish_sync(event)

        # Check that both handlers were called with the event
        handler1.assert_called_once()
        handler2.assert_called_once()

        # Check event data
        self.assertEqual(handler1.call_args[0][0].message, "Hello, world!")
        self.assertEqual(handler2.call_args[0][0].message, "Hello, world!")

        # Test unsubscribe
        self.event_dispatcher.unsubscribe("test.event", handler1)

        # Publish another event
        event = TestEvent(message="Second event")
        self.event_dispatcher.publish_sync(event)

        # First handler should still have been called only once
        self.assertEqual(handler1.call_count, 1)

        # Second handler should have been called twice
        self.assertEqual(handler2.call_count, 2)

    def test_context_request_response_flow(self):
        """Test the flow of ContextRequest and ContextResponse events."""

        # Set up a handler for context requests
        def context_handler(event: ContextRequest):
            # Create a response with test data
            response = ContextResponse(
                character_id=event.character_id,
                npc_id=event.npc_id,
                context_data={"test_key": "test_value"},
            )
            # Publish the response
            EventDispatcher.get_instance().publish_sync(response)

        # Subscribe to context requests
        self.event_dispatcher.subscribe(ContextRequest, context_handler)

        # Set up a mock handler for the response
        response_handler = MagicMock()
        self.event_dispatcher.subscribe(ContextResponse, response_handler)

        # Create and publish a context request
        request = ContextRequest(character_id="test_player", npc_id="test_npc")
        self.event_dispatcher.publish_sync(request)

        # Check that the response handler was called
        response_handler.assert_called_once()

        # Check the response data
        response = response_handler.call_args[0][0]
        self.assertEqual(response.character_id, "test_player")
        self.assertEqual(response.npc_id, "test_npc")
        self.assertEqual(response.context_data["test_key"], "test_value")

    def test_memory_event_handling(self):
        """Test that memory events are properly processed."""
        # Create a mock handler for memory events
        memory_handler = MagicMock()

        # Subscribe to memory events
        self.event_dispatcher.subscribe(MemoryEvent, memory_handler)

        # Create and publish a memory event
        memory_event = MemoryEvent(
            event_type="memory.created",
            entity_id="test_player",
            memory_id="test_memory",
            operation="created",
            memory_data={"content": "Test memory content"},
            importance=0.7,
            tags=["test", "important"],
        )
        self.event_dispatcher.publish_sync(memory_event)

        # Check that the handler was called
        memory_handler.assert_called_once()

        # Check the event data
        event = memory_handler.call_args[0][0]
        self.assertEqual(event.entity_id, "test_player")
        self.assertEqual(event.memory_id, "test_memory")
        self.assertEqual(event.operation, "created")
        self.assertEqual(event.memory_data["content"], "Test memory content")
        self.assertEqual(event.importance, 0.7)
        self.assertEqual(event.tags, ["test", "important"])

    def test_rumor_event_handling(self):
        """Test that rumor events are properly processed."""
        # Create a mock handler for rumor events
        rumor_handler = MagicMock()

        # Subscribe to rumor events
        self.event_dispatcher.subscribe(RumorEvent, rumor_handler)

        # Create and publish a rumor event
        rumor_event = RumorEvent(
            event_type="rumor.created",
            rumor_id="test_rumor",
            source_entity_id="test_npc",
            target_entity_ids=["test_player"],
            rumor_type="treasure",
            rumor_data={"content": "There's treasure hidden in the mountains"},
            mutated=False,
        )
        self.event_dispatcher.publish_sync(rumor_event)

        # Check that the handler was called
        rumor_handler.assert_called_once()

        # Check the event data
        event = rumor_handler.call_args[0][0]
        self.assertEqual(event.rumor_id, "test_rumor")
        self.assertEqual(event.source_entity_id, "test_npc")
        self.assertEqual(event.target_entity_ids, ["test_player"])
        self.assertEqual(event.rumor_type, "treasure")
        self.assertEqual(
            event.rumor_data["content"], "There's treasure hidden in the mountains"
        )
        self.assertEqual(event.mutated, False)

    def test_motif_event_handling(self):
        """Test that motif events are properly processed."""
        # Create a mock handler for motif events
        motif_handler = MagicMock()

        # Subscribe to motif events
        self.event_dispatcher.subscribe(MotifEvent, motif_handler)

        # Create and publish a motif event
        motif_event = MotifEvent(
            event_type="motif.created",
            motif_id="test_motif",
            motif_name="Test Motif",
            motif_category="betrayal",
            entity_id="test_player",
            region_id="test_region",
            occurrence_id="test_occurrence",
            strength=0.8,
        )
        self.event_dispatcher.publish_sync(motif_event)

        # Check that the handler was called
        motif_handler.assert_called_once()

        # Check the event data
        event = motif_handler.call_args[0][0]
        self.assertEqual(event.motif_id, "test_motif")
        self.assertEqual(event.motif_name, "Test Motif")
        self.assertEqual(event.motif_category, "betrayal")
        self.assertEqual(event.entity_id, "test_player")
        self.assertEqual(event.region_id, "test_region")
        self.assertEqual(event.occurrence_id, "test_occurrence")
        self.assertEqual(event.strength, 0.8)

    def test_repository_data_access(self):
        """Test that repositories correctly handle data operations."""
        # Test player repository
        player_data = self.player_repo.get_player_data("test_player")
        self.assertEqual(player_data["name"], "Test Player")
        self.assertEqual(player_data["region_id"], "test_region")

        # Test region repository
        region_data = self.region_repo.get_region_data("test_region")
        self.assertEqual(region_data["name"], "Test Region")
        self.assertEqual(region_data["biome"], "forest")

        # Test NPC repository
        npc_data = self.npc_repo.get_npc_data("test_npc")
        self.assertEqual(npc_data["name"], "Test NPC")
        self.assertEqual(npc_data["region_id"], "test_region")

        # Test faction repository
        faction_data = self.faction_repo.get_faction_data("test_faction")
        self.assertEqual(faction_data["name"], "Test Faction")
        self.assertEqual(faction_data["type"], "political")

        # Test motif repository
        motif_data = self.motif_repo.get_motif_data("test_motif")
        self.assertEqual(motif_data["name"], "Test Motif")
        self.assertEqual(motif_data["category"], "betrayal")

        # Test rumor repository
        rumor_data = self.rumor_repo.get_rumor_data("test_rumor")
        self.assertEqual(rumor_data["rumor_type"], "treasure")
        self.assertEqual(rumor_data["region_id"], "test_region")

    def test_repository_data_update(self):
        """Test that repositories correctly handle data updates."""
        # Update player data
        player_data = self.player_repo.get_player_data("test_player")
        player_data["motifs"]["active"].append(
            {"theme": "honor", "weight": 3, "added_at": datetime.utcnow().isoformat()}
        )
        self.player_repo.update_player_data("test_player", player_data)

        # Verify the update
        updated_player = self.player_repo.get_player_data("test_player")
        self.assertEqual(len(updated_player["motifs"]["active"]), 2)
        self.assertEqual(updated_player["motifs"]["active"][1]["theme"], "honor")

        # Update region data
        region_data = self.region_repo.get_region_data("test_region")
        region_data["tension"]["level"] = 5
        region_data["tension"]["label"] = "high"
        self.region_repo.update_region_data("test_region", region_data)

        # Verify the update
        updated_region = self.region_repo.get_region_data("test_region")
        self.assertEqual(updated_region["tension"]["level"], 5)
        self.assertEqual(updated_region["tension"]["label"], "high")

    def test_dungeonmaster_integration(self):
        """Test that DungeonMaster integrates correctly with event system."""
        # Create a DungeonMaster instance
        dm = DungeonMaster.get_instance()

        # Create a mock for GPT client
        with patch("backend.systems.llm.core.dm_core.GPTClient") as mock_gpt:
            mock_gpt_instance = MagicMock()
            mock_gpt.return_value = mock_gpt_instance

            # Test context request handling
            context_event = ContextRequest(
                character_id="test_player", npc_id="test_npc"
            )

            # Set up a mock handler for context responses
            response_handler = MagicMock()
            self.event_dispatcher.subscribe(ContextResponse, response_handler)

            # Publish the context request
            self.event_dispatcher.publish_sync(context_event)

            # Check that a response was generated
            response_handler.assert_called_once()

            # Check response data
            response = response_handler.call_args[0][0]
            self.assertEqual(response.character_id, "test_player")
            self.assertEqual(response.npc_id, "test_npc")
            self.assertIsNotNone(response.context_data)

            # Verify that repositories were used
            self.assertIn("player_motifs", response.context_data)
            self.assertIn("npc_motifs", response.context_data)
            self.assertIn("region_tension", response.context_data)

    def test_integrated_event_flow(self):
        """Test the integrated flow of events between components."""
        # Create the DungeonMaster instance
        dm = DungeonMaster.get_instance()

        # Create a memory event
        memory_event = MemoryEvent(
            event_type="memory.created",
            entity_id="test_player",
            memory_id="test_memory",
            operation="created",
            memory_data={"content": "I met an interesting person"},
            importance=0.6,
            tags=["meeting", "important"],
        )

        # Create a mock handler to track DM's memory handler being called
        dm._on_memory_created = MagicMock()

        # Publish the memory event
        self.event_dispatcher.publish_sync(memory_event)

        # Check that DM's memory handler was called
        dm._on_memory_created.assert_called_once()
        self.assertEqual(dm._on_memory_created.call_args[0][0].entity_id, "test_player")

        # Create a rumor event
        rumor_event = RumorEvent(
            event_type="rumor.created",
            rumor_id="new_rumor",
            source_entity_id="test_npc",
            target_entity_ids=["test_player"],
            rumor_type="secret",
            rumor_data={"content": "The faction leader has a hidden agenda"},
        )

        # Create a mock handler to track DM's rumor handler being called
        dm._on_rumor_created = MagicMock()

        # Publish the rumor event
        self.event_dispatcher.publish_sync(rumor_event)

        # Check that DM's rumor handler was called
        dm._on_rumor_created.assert_called_once()
        self.assertEqual(dm._on_rumor_created.call_args[0][0].rumor_id, "new_rumor")

        # Create a motif event
        motif_event = MotifEvent(
            event_type="motif.created",
            motif_id="new_motif",
            motif_name="New Motif",
            motif_category="revenge",
            entity_id="test_player",
            region_id="test_region",
            strength=0.9,
        )

        # Create a mock handler to track DM's motif handler being called
        dm._on_motif_created = MagicMock()

        # Publish the motif event
        self.event_dispatcher.publish_sync(motif_event)

        # Check that DM's motif handler was called
        dm._on_motif_created.assert_called_once()
        self.assertEqual(dm._on_motif_created.call_args[0][0].motif_id, "new_motif")


if __name__ == "__main__":
    unittest.main()
