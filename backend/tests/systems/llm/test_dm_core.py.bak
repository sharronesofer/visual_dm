"""
Unit tests for the Dungeon Master core module.

These tests validate the DM core functionality:
1. Initialization and singleton pattern
2. Context management and persistence
3. Event handling and processing
4. Narrative generation and context building
5. Integration with subsystems (memory, motif, faction, etc.)
"""

import unittest
import os
import json
import tempfile
import shutil
from datetime import datetime
from unittest.mock import patch, MagicMock, AsyncMock

from backend.systems.llm.core.dm_core import (
    DungeonMaster,
    ContextRequest,
    ContextResponse,
    QuestReminderEvent,
    RequestClassificationEvent,
    gather_dm_context,
    gather_relationship_context,
    gather_faction_context,
)
from backend.systems.llm.core.event_integration import EventDispatcher
from backend.systems.llm.repositories.player_repository import PlayerRepository
from backend.systems.llm.repositories.region_repository import RegionRepository
from backend.systems.llm.repositories.npc_repository import NPCRepository
from backend.systems.llm.repositories.faction_repository import FactionRepository
from backend.systems.llm.repositories.world_repository import WorldRepository
from backend.systems.llm.repositories.motif_repository import MotifRepository
from backend.systems.llm.repositories.rumor_repository import RumorRepository
from backend.systems.llm.core.memory_system import MemoryManager
from backend.systems.rumor import RumorService
from backend.systems.llm.core.motif_system import MotifManager
from backend.systems.llm.core.faction_system import FactionManager


class TestDungeonMasterCore(unittest.TestCase):
    """Unit tests for the DungeonMaster class and related functions."""

    def setUp(self):
        """Set up test environment with a temporary data directory."""
        # Create temporary data directory
        self.temp_dir = tempfile.mkdtemp()
        os.environ["VDM_DATA_DIR"] = self.temp_dir

        # Create necessary subdirectories
        os.makedirs(os.path.join(self.temp_dir, "entities", "players"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "entities", "npcs"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "entities", "factions"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "world", "regions"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "motifs"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "rumors"), exist_ok=True)
        os.makedirs(os.path.join(self.temp_dir, "memories"), exist_ok=True)

        # Reset singleton instances
        EventDispatcher._instance = None
        PlayerRepository._instance = None
        RegionRepository._instance = None
        NPCRepository._instance = None
        FactionRepository._instance = None
        WorldRepository._instance = None
        MotifRepository._instance = None
        RumorRepository._instance = None
        DungeonMaster._instance = None
        MemoryManager._instance = None
        RumorService._instance = None
        MotifManager._instance = None
        FactionManager._instance = None

        # Create test data
        self._create_test_data()

        # Get instance with dependencies properly initialized
        self.event_dispatcher = EventDispatcher.get_instance()
        self.player_repo = PlayerRepository.get_instance()
        self.region_repo = RegionRepository.get_instance()
        self.npc_repo = NPCRepository.get_instance()
        self.faction_repo = FactionRepository.get_instance()
        self.world_repo = WorldRepository.get_instance()
        self.motif_repo = MotifRepository.get_instance()
        self.rumor_repo = RumorRepository.get_instance()
        self.memory_manager = MemoryManager.get_instance()
        self.rumor_service = RumorService.get_instance()
        self.motif_manager = MotifManager.get_instance()
        self.faction_manager = FactionManager.get_instance()

        # Now instantiate DM instance
        self.dm = DungeonMaster.get_instance()

    def tearDown(self):
        """Clean up after tests."""
        shutil.rmtree(self.temp_dir)

    def _create_test_data(self):
        """Create test data for repositories."""
        # Create player repository test data
        player_data = {
            "id": "test_player",
            "name": "Test Player",
            "region_id": "test_region",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "motifs": {
                "active": [
                    {
                        "theme": "vengeance",
                        "weight": 5,
                        "added_at": datetime.utcnow().isoformat(),
                    }
                ],
                "expired": [],
            },
            "relationships": {
                "npc": {
                    "test_npc": {
                        "standing": 0.7,
                        "reputation": 0.5,
                        "updated_at": datetime.utcnow().isoformat(),
                    }
                },
                "faction": {
                    "test_faction": {
                        "standing": 0.3,
                        "reputation": 0.2,
                        "updated_at": datetime.utcnow().isoformat(),
                    }
                },
            },
        }
        player_file = os.path.join(
            self.temp_dir, "entities", "players", "test_player.json"
        )
        with open(player_file, "w") as f:
            json.dump(player_data, f)

        # Create NPC repository test data
        npc_data = {
            "id": "test_npc",
            "name": "Test NPC",
            "region_id": "test_region",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "motifs": {
                "active": [
                    {
                        "theme": "betrayal",
                        "weight": 3,
                        "added_at": datetime.utcnow().isoformat(),
                    }
                ],
                "expired": [],
            },
            "faction_affiliations": [{"id": "test_faction", "loyalty": 2}],
        }
        npc_file = os.path.join(self.temp_dir, "entities", "npcs", "test_npc.json")
        with open(npc_file, "w") as f:
            json.dump(npc_data, f)

        # Create faction repository test data
        faction_data = {
            "id": "test_faction",
            "name": "Test Faction",
            "description": "A faction for testing",
            "type": "political",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "regions": ["test_region"],
            "power_level": 5,
            "stability": 0.8,
        }
        faction_file = os.path.join(
            self.temp_dir, "entities", "factions", "test_faction.json"
        )
        with open(faction_file, "w") as f:
            json.dump(faction_data, f)

        # Create region repository test data
        region_data = {
            "id": "test_region",
            "name": "Test Region",
            "description": "A region for testing",
            "biome": "forest",
            "version": 1,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "tension": {"level": 3, "label": "moderate"},
            "arc": {
                "title": "Test Arc",
                "theme": "conflict",
                "milestones": [
                    {
                        "title": "Beginning of Conflict",
                        "description": "Tensions rise in the region",
                        "completed": True,
                    },
                    {
                        "title": "Escalation",
                        "description": "Conflict worsens",
                        "completed": False,
                    },
                ],
            },
        }
        region_file = os.path.join(
            self.temp_dir, "world", "regions", "test_region.json"
        )
        with open(region_file, "w") as f:
            json.dump(region_data, f)

    def test_singleton_pattern(self):
        """Test the DungeonMaster singleton pattern."""
        dm1 = DungeonMaster.get_instance()
        dm2 = DungeonMaster.get_instance()
        self.assertIs(dm1, dm2)
        self.assertIs(dm1, self.dm)

    def test_event_handlers_registration(self):
        """Test that event handlers are registered correctly."""
        # Create a mock EventDispatcher to verify handler registration
        with patch(
            "backend.systems.llm.core.event_integration.EventDispatcher.get_instance"
        ) as mock_dispatcher:
            mock_dispatcher.return_value = MagicMock()

            # Reset the singleton to trigger initialization
            DungeonMaster._instance = None
            dm = DungeonMaster.get_instance()

            # Verify handler registration
            subscribe_calls = mock_dispatcher.return_value.subscribe.call_args_list

            # Create a set of registered event types
            registered_events = set()
            for call in subscribe_calls:
                registered_events.add(call[0][0])

            # Verify that key events are subscribed
            expected_events = {
                "context.request",
                "memory.created",
                "memory.reinforced",
                "rumor.created",
                "rumor.spread",
                "motif.created",
                "motif.occurrence",
                "faction.relationship_changed",
                "quest.reminder",
                "request.classification",
            }

            # Check that all expected events are registered
            for event in expected_events:
                self.assertIn(event, registered_events)

    def test_context_request_handling(self):
        """Test handling of context requests."""
        # Create a RequestDispatcher that will capture the response
        response_data = {"captured": None}

        def context_response_handler(event):
            if isinstance(event, ContextResponse):
                response_data["captured"] = event

        self.event_dispatcher.subscribe(
            ContextResponse.event_type, context_response_handler
        )

        # Create and publish a context request
        request = ContextRequest(character_id="test_player", npc_id="test_npc")
        self.event_dispatcher.publish_sync(request)

        # Verify that a response was generated
        self.assertIsNotNone(response_data["captured"])
        response = response_data["captured"]

        # Check the response fields
        self.assertEqual(response.character_id, "test_player")
        self.assertEqual(response.npc_id, "test_npc")
        self.assertIsInstance(response.context_data, dict)

        # Check that the context contains expected data sections
        context = response.context_data
        self.assertIn("player_motifs", context)
        self.assertIn("npc_motifs", context)
        self.assertIn("region_tension", context)

    def test_gather_dm_context(self):
        """Test the gather_dm_context function."""
        # Get context for a character
        context = gather_dm_context("test_player", "test_npc")

        # Verify that the context contains expected sections
        self.assertIn("player_motifs", context)
        self.assertIn("npc_motifs", context)
        self.assertIn("region_tension", context)
        self.assertIn("region_arc", context)

        # Verify the content of the sections
        self.assertIn("vengeance", str(context["player_motifs"]))
        self.assertIn("betrayal", str(context["npc_motifs"]))
        self.assertEqual(context["region_tension"]["level"], 3)
        self.assertEqual(context["region_arc"]["title"], "Test Arc")

        # Test caching behavior
        with patch(
            "backend.systems.llm.core.dm_core.EventDispatcher.get_instance"
        ) as mock_dispatcher:
            # Call again - should use cache, not trigger new events
            context2 = gather_dm_context("test_player", "test_npc")
            mock_dispatcher.assert_not_called()

    def test_gather_relationship_context(self):
        """Test the gather_relationship_context function."""
        # Get relationship context
        relationship = gather_relationship_context("test_npc", "test_player")

        # Verify that relationship data is correct
        self.assertIsNotNone(relationship)
        self.assertIn("standing", relationship)
        self.assertIn("reputation", relationship)
        self.assertEqual(relationship["standing"], 0.7)
        self.assertEqual(relationship["reputation"], 0.5)

    def test_gather_faction_context(self):
        """Test the gather_faction_context function."""
        # Get faction context
        faction_context = gather_faction_context("test_npc", "test_player")

        # Verify that faction context data is correct
        self.assertIsNotNone(faction_context)
        self.assertIn("test_faction", str(faction_context))
        self.assertEqual(faction_context[0]["name"], "Test Faction")
        self.assertEqual(faction_context[0]["loyalty"], 2)

    @patch("backend.systems.llm.services.gpt_client.GPTClient")
    async def test_create_memory(self, mock_gpt_client):
        """Test the create_memory method."""
        # Setup mock
        mock_gpt_client.get_instance.return_value = MagicMock()

        # Create memory
        memory = self.dm.create_memory(
            entity_id="test_npc",
            content="Test memory content",
            importance=0.8,
            is_core=True,
            tags=["test", "important"],
        )

        # Verify the memory was created
        self.assertIsNotNone(memory)
        self.assertEqual(memory.entity_id, "test_npc")
        self.assertEqual(memory.content, "Test memory content")
        self.assertEqual(memory.importance, 0.8)
        self.assertTrue(memory.is_core)
        self.assertEqual(memory.tags, ["test", "important"])

    @patch("backend.systems.llm.services.gpt_client.GPTClient")
    async def test_create_rumor(self, mock_gpt_client):
        """Test the create_rumor method."""
        # Setup mock
        mock_gpt_client.get_instance.return_value = MagicMock()

        # Create rumor
        rumor = self.dm.create_rumor(
            content="Test rumor content",
            rumor_type="secret",
            source_entity_id="test_npc",
            truth_value=0.5,
            severity=3,
            region_id="test_region",
            tags=["test", "secret"],
        )

        # Verify the rumor was created
        self.assertIsNotNone(rumor)
        self.assertEqual(rumor.content, "Test rumor content")
        self.assertEqual(rumor.rumor_type, "secret")
        self.assertEqual(rumor.source_entity_id, "test_npc")
        self.assertEqual(rumor.truth_value, 0.5)
        self.assertEqual(rumor.severity, 3)
        self.assertEqual(rumor.region_id, "test_region")
        self.assertEqual(rumor.tags, ["test", "secret"])

    @patch("backend.systems.llm.services.gpt_client.GPTClient")
    async def test_get_full_narrative_context(self, mock_gpt_client):
        """Test the get_full_narrative_context method."""
        # Setup mock
        mock_instance = MagicMock()
        mock_gpt_client.get_instance.return_value = mock_instance

        # Get narrative context
        context = self.dm.get_full_narrative_context(
            entity_id="test_player", region_id="test_region"
        )

        # Verify that the context contains expected sections
        self.assertIsInstance(context, str)
        self.assertIn("Player Motifs:", context)
        self.assertIn("Region Information:", context)

    @patch("backend.systems.llm.services.gpt_client.GPTClient.get_instance")
    async def test_classify_request(self, mock_get_instance):
        """Test the classify_request function."""
        # Setup mock
        mock_client = MagicMock()
        mock_client.generate_text = AsyncMock(return_value="dialogue")
        mock_get_instance.return_value = mock_client

        # Mock the event dispatcher to capture the classification event
        event_data = {"captured": None}

        def capture_event(event):
            if isinstance(event, RequestClassificationEvent):
                event_data["captured"] = event

        self.event_dispatcher.subscribe(
            RequestClassificationEvent.event_type, capture_event
        )

        # Call the function
        classification = await classify_request(
            prompt="Hello NPC, how are you?", character_id="test_player"
        )

        # Verify the result
        self.assertEqual(classification, "dialogue")
        self.assertIsNotNone(event_data["captured"])
        event = event_data["captured"]
        self.assertEqual(event.character_id, "test_player")
        self.assertEqual(event.prompt, "Hello NPC, how are you?")
        self.assertEqual(event.classification, "dialogue")

    @patch("backend.systems.llm.services.gpt_client.GPTClient.get_instance")
    async def test_generate_npc_quest_reminder(self, mock_get_instance):
        """Test the generate_npc_quest_reminder function."""
        # Setup mock
        mock_client = MagicMock()
        mock_client.generate_text = AsyncMock(
            return_value="Don't forget about your quest!"
        )
        mock_get_instance.return_value = mock_client

        # Mock the event dispatcher to capture the reminder event
        event_data = {"captured": None}

        def capture_event(event):
            if isinstance(event, QuestReminderEvent):
                event_data["captured"] = event

        self.event_dispatcher.subscribe(QuestReminderEvent.event_type, capture_event)

        # Call the function
        reminder = await generate_npc_quest_reminder(
            npc_id="test_npc", player_id="test_player"
        )

        # Verify the result
        self.assertEqual(reminder, "Don't forget about your quest!")
        self.assertIsNotNone(event_data["captured"])
        event = event_data["captured"]
        self.assertEqual(event.npc_id, "test_npc")
        self.assertEqual(event.player_id, "test_player")

    def test_fetch_faction_name(self):
        """Test fetching faction name from various sources."""
        # Test direct faction name lookup
        faction_name = self.dm.fetch_faction_name("test_faction")
        self.assertEqual(faction_name, "Test Faction")

        # Test invalid faction ID
        invalid_name = self.dm.fetch_faction_name("nonexistent_faction")
        self.assertEqual(invalid_name, "Unknown Faction")

    def test_generate_region_narration_context(self):
        """Test generating narrative context for a region."""
        # Generate context for a region
        context = self.dm.generate_region_narration_context("test_region")

        # Verify the context contains expected elements
        self.assertIsInstance(context, str)
        self.assertIn("Test Region", context)
        self.assertIn("tension", context.lower())
        self.assertIn("forest", context.lower())

    @patch("backend.systems.llm.core.memory_system.MemoryManager.get_memories")
    def test_get_memories(self, mock_get_memories):
        """Test the get_memories method."""
        # Setup mock
        mock_memories = [
            {"id": "mem1", "content": "Memory 1", "importance": 0.7},
            {"id": "mem2", "content": "Memory 2", "importance": 0.5},
        ]
        mock_get_memories.return_value = mock_memories

        # Get memories
        memories = self.dm.get_memories(
            entity_id="test_npc", query="test query", min_relevance=0.3, limit=5
        )

        # Verify the memories were retrieved
        self.assertEqual(memories, mock_memories)
        mock_get_memories.assert_called_with(
            entity_id="test_npc",
            query="test query",
            min_relevance=0.3,
            limit=5,
            include_expired=False,
            tags=None,
        )

    @patch("backend.systems.llm.core.memory_system.MemoryManager.get_memory_context")
    def test_get_memory_context(self, mock_get_memory_context):
        """Test the get_memory_context method."""
        # Setup mock
        expected_context = "Memory context for test entity"
        mock_get_memory_context.return_value = expected_context

        # Get memory context
        context = self.dm.get_memory_context(
            entity_id="test_entity", query="relevant memories", limit=5
        )

        # Verify the context was retrieved
        self.assertEqual(context, expected_context)
        mock_get_memory_context.assert_called_with(
            entity_id="test_entity", query="relevant memories", limit=5
        )

    @patch("backend.systems.rumor.service.RumorService.spread_rumor")
    async def test_spread_rumor(self, mock_spread_rumor):
        """Test the spread_rumor method."""
        # Setup mock
        mock_spread_rumor.return_value = True

        # Spread rumor
        result = await self.dm.spread_rumor(
            rumor_id="test_rumor", from_entity_id="test_source", to_entity_id="target1"
        )

        # Verify the rumor was spread
        self.assertTrue(result)
        mock_spread_rumor.assert_called_with(
            rumor_id="test_rumor", from_entity_id="test_source", to_entity_id="target1"
        )

    @patch("backend.systems.rumor.service.RumorService.get_character_rumors")
    async def test_get_entity_rumors(self, mock_get_character_rumors):
        """Test the get_entity_rumors method."""
        # Setup mock
        expected_rumors = [
            {"id": "rumor1", "content": "Rumor 1", "truth_value": 0.7},
            {"id": "rumor2", "content": "Rumor 2", "truth_value": 0.5},
        ]
        mock_get_character_rumors.return_value = expected_rumors

        # Get entity rumors
        rumors = await self.dm.get_entity_rumors(entity_id="test_entity")

        # Verify the rumors were retrieved
        self.assertEqual(rumors, expected_rumors)
        mock_get_character_rumors.assert_called_with(character_id="test_entity")

    @patch("backend.systems.llm.core.motif_system.MotifManager.record_motif_occurrence")
    def test_record_motif_occurrence(self, mock_record_occurrence):
        """Test the record_motif_occurrence method."""
        # Record motif occurrence
        self.dm.record_motif_occurrence(
            motif_id="test_motif",
            narrative_text="Test narrative",
            entity_id="test_entity",
            region_id="test_region",
            event_id="test_event",
            strength=0.8,
        )

        # Verify the occurrence was recorded
        mock_record_occurrence.assert_called_with(
            motif_id="test_motif",
            narrative_text="Test narrative",
            entity_id="test_entity",
            region_id="test_region",
            event_id="test_event",
            strength=0.8,
        )

    def test_event_handlers(self):
        """Test the event handler methods."""
        # Test memory created handler
        memory_event = MagicMock()
        memory_event.memory_id = "test_memory"
        memory_event.entity_id = "test_entity"
        self.dm._on_memory_created(memory_event)

        # Test memory reinforced handler
        reinforce_event = MagicMock()
        reinforce_event.memory_id = "test_memory"
        reinforce_event.entity_id = "test_entity"
        reinforce_event.old_relevance = 0.5
        reinforce_event.new_relevance = 0.7
        self.dm._on_memory_reinforced(reinforce_event)

        # Test rumor created handler
        rumor_event = MagicMock()
        rumor_event.rumor_id = "test_rumor"
        rumor_event.source_entity_id = "test_entity"
        rumor_event.rumor_type = "secret"
        self.dm._on_rumor_created(rumor_event)

        # Test rumor spread handler
        spread_event = MagicMock()
        spread_event.rumor_id = "test_rumor"
        spread_event.source_entity_id = "test_source"
        spread_event.target_entity_ids = ["target1", "target2"]
        spread_event.mutation_created = True
        spread_event.mutation_id = "test_mutation"
        self.dm._on_rumor_spread(spread_event)


# Run the tests
if __name__ == "__main__":
    unittest.main()
