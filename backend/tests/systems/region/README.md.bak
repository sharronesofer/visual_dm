# Region System Tests

This directory contains tests for the Visual DM's region system, which manages geographical divisions, their properties, and relationships within the game world.

## Overview

The region system provides:
- Spatial framework for the game world, organized into continents and regions
- Region-specific properties (biomes, resources, features)
- Weather and environmental systems
- Event tracking within geographic contexts

## Test Structure

The test suite is organized as follows:

### Infrastructure
- **conftest.py**: Shared fixtures, including mock data, temporary directories, and common test utilities
- **pytest.ini**: Configuration for test discovery and execution

### Test Modules
- **test_schemas.py**: Tests for data models and validation
- **test_repository.py**: Tests for data persistence and retrieval
- **test_service.py**: Tests for the main service layer and business logic
- **test_router.py**: Tests for API endpoints using FastAPI TestClient
- **test_mapping.py**: Tests for coordinate mapping and weather calculation systems
- **test_region_gen.py**: Tests for region generation functionality
- **test_continent.py**: Tests for continent generation functionality
- **test_worldgen.py**: Tests for world generation functionality
- **test_tension.py**: Tests for tension management functionality
- **test_utils.py**: Tests for utility functions

## Running the Tests

### Using the Test Runner Script

For convenience, a test runner script is provided at `scripts/run_region_tests.sh`. This script offers several options:

```bash
# Run all region tests
./scripts/run_region_tests.sh

# Run with verbose output
./scripts/run_region_tests.sh --verbose

# Run with coverage reporting
./scripts/run_region_tests.sh --coverage

# Generate HTML coverage report
./scripts/run_region_tests.sh --coverage --html

# Run tests matching a specific pattern
./scripts/run_region_tests.sh --pattern="test_mapping or test_repository"
```

### Using pytest Directly

You can also run the tests using pytest commands directly:

```bash
# Run all region tests
python -m pytest backend/tests/systems/region/

# Run with verbose output
python -m pytest backend/tests/systems/region/ -v

# Run a specific test file
python -m pytest backend/tests/systems/region/test_mapping.py

# Run with coverage
python -m pytest backend/tests/systems/region/ --cov=backend.systems.region --cov-report=term-missing
```

## Testing Strategy

### Unit Tests
- Test individual functions in isolation
- Mock external dependencies
- Focus on edge cases and input validation

### Integration Tests
- Test interaction between modules
- Ensure correct data flow between layers
- Verify that components work together properly

### API Tests
- Test HTTP endpoints using FastAPI's TestClient
- Verify correct response codes and payload structures
- Test error handling and edge cases

## Fixtures and Mocks

The test suite provides several fixtures in `conftest.py` to facilitate testing:

- **temp_data_dir**: A temporary directory for storing test data
- **mock_data_registry**: Mock for the GameDataRegistry that provides test biome and terrain data
- **mock_world_generator**: Mock for the WorldGenerator used by the RegionService
- **sample_region_data**: Sample region data for testing schemas and validation
- **sample_continent_data**: Sample continent data for testing continent operations

## Coverage Goals

The test suite aims to achieve high coverage across all modules:

1. **Core functionality**: 100% coverage of business logic and data models
2. **API endpoints**: 100% coverage of endpoint handlers and error cases
3. **Helper functions**: >90% coverage of utility functions
4. **Generator functions**: >80% coverage of procedural generation logic

## Adding New Tests

When adding new tests:

1. Follow the existing naming convention: `test_<module>.py`
2. Group related tests into classes named `Test<Component>`
3. Use descriptive function names (`test_should_validate_coordinates_correctly`)
4. Use fixtures from `conftest.py` when possible
5. Add docstrings to test classes and functions
6. Consider edge cases and error conditions

## Mock Strategies

Different components require different mocking approaches:

- **Repository functions**: Use `mock_open` to simulate file operations
- **External services**: Use `MagicMock` with `return_value` or `side_effect`
- **Random functions**: Use `patch` to make randomness deterministic
- **Time functions**: Use fixed timestamps for consistent results

## Continuous Integration

These tests are integrated into the CI pipeline and will run on pull requests to ensure code quality and prevent regressions.

## Test Data

Test data for the region system is separated into:

1. **Fixture Data**: Defined in `conftest.py` and used across multiple tests
2. **Test-Specific Data**: Defined within individual test files for specific scenarios
3. **Generated Data**: Created during test execution for specific test cases

## Note on Performance

Region generation can be computationally intensive, so some tests may take longer to run. Consider using the `--pattern` option to run specific test modules during development. 