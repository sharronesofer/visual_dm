"""
Tests for the rumor service.

This module tests the RumorService class that handles
business logic for the rumor system.
"""

import unittest
from unittest.mock import AsyncMock, patch, MagicMock
import json
import uuid
from datetime import datetime, timedelta

from backend.systems.rumor.models.rumor import (
    Rumor,
    RumorVariant,
    RumorSpread,
    RumorCategory,
    RumorSeverity,
)
from backend.systems.rumor.service import RumorService
from backend.systems.rumor.repository import RumorRepository


class TestRumorService(unittest.IsolatedAsyncioTestCase):
    """Test case for the RumorService class."""

    async def asyncSetUp(self):
        """Set up the test case."""
        # Create mocks for dependencies
        self.mock_repository = AsyncMock(spec=RumorRepository)
        self.mock_event_dispatcher = AsyncMock()

        # Create the service with mocked dependencies
        self.service = RumorService(
            rumor_repository=self.mock_repository,
            event_dispatcher=self.mock_event_dispatcher,
        )

        # Create a sample rumor for testing
        self.test_rumor = Rumor(
            id="test_rumor_1",
            originator_id="entity_1",
            original_content="Test rumor content",
            categories=[RumorCategory.SCANDAL],
            severity=RumorSeverity.MINOR,
            truth_value=0.6,
            variants=[
                RumorVariant(
                    id="test_variant_1",
                    content="Test variant content",
                    entity_id="entity_1",
                )
            ],
            spread=[
                RumorSpread(
                    entity_id="entity_1",  # Originator knows the rumor
                    variant_id="test_variant_1",
                    heard_from_entity_id=None,  # Originator
                    believability=1.0,
                    heard_at=datetime.utcnow(),
                )
            ],
        )

    async def test_create_rumor(self):
        """Test creating a new rumor."""
        # Setup mocks
        self.mock_repository.save_rumor = AsyncMock()

        # Call the method
        result = await self.service.create_rumor(
            originator_id="entity_1",
            content="New rumor content",
            categories=["SCANDAL", "POLITICAL"],
            severity="MINOR",
            truth_value=0.7,
        )

        # Check result
        self.assertIsNotNone(result)
        self.assertIsInstance(result, Rumor)

        # Verify repository was called
        self.mock_repository.save_rumor.assert_called_once()

        # Verify the rumor was created correctly
        self.assertEqual(result.originator_id, "entity_1")
        self.assertEqual(result.original_content, "New rumor content")
        self.assertEqual(len(result.categories), 2)
        self.assertEqual(result.severity, RumorSeverity.MINOR)
        self.assertEqual(result.truth_value, 0.7)
        self.assertEqual(len(result.variants), 1)
        self.assertEqual(result.variants[0].content, "New rumor content")
        self.assertEqual(result.variants[0].entity_id, "entity_1")

    async def test_spread_rumor_new_entity(self):
        """Test spreading a rumor to a new entity."""
        # Setup mocks
        self.mock_repository.get_rumor = AsyncMock(return_value=self.test_rumor)
        self.mock_repository.save_rumor = AsyncMock()

        # Entity that hasn't heard the rumor yet
        to_entity_id = "entity_3"

        # Call the method
        result = await self.service.spread_rumor(
            rumor_id="test_rumor_1",
            from_entity_id="entity_1",  # Originator knows the rumor
            to_entity_id=to_entity_id,
            mutation_probability=0.3,
            relationship_factor=0.7,
        )

        # Check result
        self.assertTrue(result)

        # Verify methods were called (get_rumor may be called multiple times during spread operation)
        self.mock_repository.get_rumor.assert_called_with("test_rumor_1")
        self.assertTrue(self.mock_repository.get_rumor.call_count >= 1)
        self.mock_repository.save_rumor.assert_called_once()

        # Check that the rumor was updated correctly
        saved_rumor = self.mock_repository.save_rumor.call_args[0][0]
        # Find the spread record for the new entity
        entity_spread = next(
            (s for s in saved_rumor.spread if s.entity_id == to_entity_id), None
        )
        self.assertIsNotNone(entity_spread)
        self.assertEqual(entity_spread.heard_from_entity_id, "entity_1")

    async def test_spread_rumor_not_found(self):
        """Test spreading a non-existent rumor."""
        # Setup mock
        self.mock_repository.get_rumor = AsyncMock(return_value=None)

        # Call the method
        result = await self.service.spread_rumor(
            rumor_id="non_existent_rumor",
            from_entity_id="entity_1",
            to_entity_id="entity_2",
            mutation_probability=0.3,
            relationship_factor=0.7,
        )

        # Check result
        self.assertFalse(result)

        # Verify repository was called but not save
        self.mock_repository.get_rumor.assert_called_once_with("non_existent_rumor")
        self.mock_repository.save_rumor.assert_not_called()

    async def test_spread_rumor_unknown_from_entity(self):
        """Test spreading a rumor from an entity that doesn't know it."""
        # Setup mocks
        self.mock_repository.get_rumor = AsyncMock(return_value=self.test_rumor)
        self.mock_repository.save_rumor = AsyncMock()

        # Call the method with an entity that doesn't know the rumor
        result = await self.service.spread_rumor(
            rumor_id="test_rumor_1",
            from_entity_id="entity_unknown",  # This entity doesn't know the rumor
            to_entity_id="entity_2",
            mutation_probability=0.0,
            relationship_factor=0.7,
        )

        # Check result
        self.assertFalse(result)

        # Verify repository was called but not save
        self.mock_repository.get_rumor.assert_called_once_with("test_rumor_1")
        self.mock_repository.save_rumor.assert_not_called()

    async def test_get_rumor_context(self):
        """Test retrieving context of rumors for an entity."""
        # Setup mocks for rumors
        rumor1 = self.test_rumor
        # Add entity_2 to the first rumor's spread
        self.test_rumor.spread.append(
            RumorSpread(
                entity_id="entity_2",
                variant_id="test_variant_1",
                heard_from_entity_id="entity_1",
                believability=0.8,
                heard_at=datetime.utcnow(),
            )
        )

        rumor2 = Rumor(
            id="test_rumor_2",
            originator_id="entity_3",
            original_content="Another test rumor",
            categories=[RumorCategory.CATASTROPHE],
            severity=RumorSeverity.MAJOR,
            truth_value=0.7,
            variants=[
                RumorVariant(
                    id="test_variant_2",
                    content="Another test variant content",
                    entity_id="entity_3",
                )
            ],
            spread=[
                RumorSpread(
                    entity_id="entity_2",
                    variant_id="test_variant_2",
                    heard_from_entity_id="entity_3",
                    believability=0.6,
                    heard_at=datetime.utcnow(),
                )
            ],
        )

        # Mock the repository method
        self.mock_repository.get_rumors_by_filters = AsyncMock(
            return_value=[rumor1, rumor2]
        )

        # Call the method
        result = await self.service.get_rumor_context(
            entity_id="entity_2",
            num_rumors=5,
            min_believability=0.5,
            categories=[RumorCategory.CATASTROPHE, RumorCategory.SCANDAL],
        )

        # Check result
        self.assertEqual(len(result), 2)
        # Should return the variant content as entity_2 knows it, not the original content
        self.assertEqual(result[0]["content"], "Test variant content")
        self.assertEqual(result[0]["severity"], "minor")
        self.assertIn("scandal", result[0]["categories"])
        self.assertEqual(result[1]["content"], "Another test variant content")
        self.assertEqual(result[1]["severity"], "major")
        self.assertIn("catastrophe", result[1]["categories"])

        # Verify repository method was called with correct parameters
        self.mock_repository.get_rumors_by_filters.assert_called_once()

    async def test_decay_all_rumors(self):
        """Test decaying rumors over time."""
        # Setup mocks
        rumor1 = self.test_rumor
        rumor2 = Rumor(
            id="test_rumor_2",
            originator_id="entity_3",
            original_content="Another test rumor",
            categories=[RumorCategory.CATASTROPHE],
            severity=RumorSeverity.MAJOR,
            truth_value=0.7,
            variants=[
                RumorVariant(
                    id="test_variant_2",
                    content="Another test variant content",
                    entity_id="entity_3",
                )
            ],
            spread=[
                RumorSpread(
                    entity_id="entity_2",
                    variant_id="test_variant_2",
                    heard_from_entity_id="entity_3",
                    believability=0.6,
                    heard_at=datetime.utcnow()
                    - timedelta(days=10),  # Old enough to decay
                )
            ],
        )

        self.mock_repository.get_all_rumors = AsyncMock(return_value=[rumor1, rumor2])
        self.mock_repository.save_rumor = AsyncMock()

        # Call the method
        result = await self.service.decay_all_rumors(days_inactive_threshold=7)

        # Check that something was returned (exact result depends on implementation)
        self.assertIsNotNone(result)

        # Verify methods were called
        self.mock_repository.get_all_rumors.assert_called_once()


if __name__ == "__main__":
    unittest.main()
