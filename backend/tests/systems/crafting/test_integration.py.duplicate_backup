"""
Integration tests for the crafting system.
"""

import unittest
from unittest.mock import patch, MagicMock
import json
import os
import tempfile
from pathlib import Path

from backend.systems.crafting import (
    craft,
    get_available_recipes,
    can_craft,
    learn_recipe,
    discover_recipe,
    reset_services,
)
from backend.systems.crafting.services.crafting_service import CraftingService
from backend.systems.crafting.models.recipe import CraftingRecipe
from backend.systems.crafting.models.ingredient import CraftingIngredient
from backend.systems.crafting.models.result import CraftingResult
from backend.systems.crafting.models.station import CraftingStation


class TestCraftingIntegration(unittest.TestCase):
    """Integration tests for the crafting system."""

    def setUp(self):
        """Set up test fixtures."""
        # Reset services first to ensure clean state
        reset_services()
        
        # Create test data
        self.recipe_data = {
            "iron_sword": {
                "name": "Iron Sword",
                "description": "A basic iron sword, effective in combat.",
                "skill_required": "smithing",
                "min_skill_level": 2,
                "station_required": "smithy",
                "station_level": 1,
                "ingredients": [
                    {
                        "item_id": "iron_ingot",
                        "quantity": 3,
                        "is_consumed": True,
                        "substitution_groups": {"low_quality": {"scrap_metal": 5}},
                    },
                    {"item_id": "leather_strip", "quantity": 2, "is_consumed": True},
                ],
                "results": [
                    {"item_id": "iron_sword", "quantity": 1, "probability": 1.0}
                ],
                "is_hidden": False,
                "is_enabled": True,
                "discovery_methods": ["smith_mentor"],
                "metadata": {
                    "base_experience": 15,
                    "quality_modifiers": {"damage": 2, "durability": 5},
                },
            },
            "leather_armor": {
                "name": "Leather Armor",
                "description": "Basic leather armor for protection.",
                "skill_required": "leatherworking",
                "min_skill_level": 1,
                "station_required": "tanning_rack",
                "station_level": 1,
                "ingredients": [
                    {"item_id": "leather", "quantity": 5, "is_consumed": True},
                    {"item_id": "leather_strip", "quantity": 3, "is_consumed": True},
                ],
                "results": [
                    {"item_id": "leather_armor", "quantity": 1, "probability": 1.0}
                ],
                "is_hidden": False,
                "is_enabled": True,
                "discovery_methods": ["leatherworker_mentor"],
                "metadata": {
                    "base_experience": 10,
                    "quality_modifiers": {"armor": 1, "durability": 3},
                },
            },
        }

        self.station_data = {
            "basic_smithy": {
                "name": "Basic Smithy",
                "description": "A simple forge for basic metalworking.",
                "type": "smithy",
                "level": 1,
                "metadata": {
                    "required_space": 4,
                    "build_materials": {"stone": 10, "iron": 5, "wood": 15},
                    "allowed_categories": ["weapons", "armor", "tools"],
                },
            },
            "tanning_rack": {
                "name": "Tanning Rack",
                "description": "A rack for tanning hides into leather.",
                "type": "tanning_rack",
                "level": 1,
                "metadata": {
                    "required_space": 2,
                    "build_materials": {"wood": 10, "leather": 2},
                    "allowed_categories": ["armor", "materials"],
                },
            },
        }

        # Mock inventory for testing
        self.inventory_data = {
            "character1_inventory": {
                "iron_ingot": 5,
                "leather_strip": 5,
                "leather": 10,
                "scrap_metal": 10,
            }
        }

        # Set up mocks for external dependencies
        self.patches = [
            patch(
                "backend.systems.events.event_dispatcher.EventDispatcher.get_instance"
            ),
            patch("backend.systems.inventory.repository.InventoryItemRepository"),
            patch("backend.core.database.db"),
        ]

        # Start all patches
        for p in self.patches:
            p.start()

        # Create temporary directories for recipe and station data
        self.temp_dir = tempfile.TemporaryDirectory()
        self.recipe_dir = Path(self.temp_dir.name) / "recipes"
        self.station_dir = Path(self.temp_dir.name) / "stations"
        self.recipe_dir.mkdir()
        self.station_dir.mkdir()

        # Write test data to files
        with open(self.recipe_dir / "test_recipes.json", "w") as f:
            json.dump(self.recipe_data, f)

        with open(self.station_dir / "test_stations.json", "w") as f:
            json.dump(self.station_data, f)

        # Set environment variables
        os.environ["RECIPE_DIR"] = str(self.recipe_dir)
        os.environ["STATION_DIR"] = str(self.station_dir)

        # Create mock for inventory operations
        self.mock_inventory_service()

    def tearDown(self):
        """Clean up after tests."""
        # Stop all patches
        for p in self.patches:
            p.stop()

        # Clean up temporary directory
        self.temp_dir.cleanup()

        # Reset environment variables
        if "RECIPE_DIR" in os.environ:
            del os.environ["RECIPE_DIR"]
        if "STATION_DIR" in os.environ:
            del os.environ["STATION_DIR"]

        # Reset services
        reset_services()

    def mock_inventory_service(self):
        """
        Create mocks for inventory operations.
        """
        # Mock inventory operations to simulate real behavior

        # Mock _validate_inventory to check against our inventory data
        def mock_validate_inventory(
            self, recipe, inventory_id, allow_substitutions=True
        ):
            if inventory_id not in TestCraftingIntegration.inventory_data:
                return False, "Inventory not found"

            inventory = TestCraftingIntegration.inventory_data[inventory_id]

            for ingredient in recipe.ingredients:
                if (
                    ingredient.item_id in inventory
                    and inventory[ingredient.item_id] >= ingredient.quantity
                ):
                    continue

                # Check substitutions if allowed
                if allow_substitutions and ingredient.substitution_groups:
                    found_sub = False
                    for group, subs in ingredient.substitution_groups.items():
                        for sub_item, sub_qty in subs.items():
                            if sub_item in inventory and inventory[sub_item] >= sub_qty:
                                found_sub = True
                                break
                        if found_sub:
                            break

                    if found_sub:
                        continue

                return False, f"Missing required ingredient: {ingredient.item_id}"

            return True, ""

        # Mock _process_ingredients to modify our inventory data
        def mock_process_ingredients(
            self, recipe, inventory_id, allow_substitutions=True
        ):
            inventory = TestCraftingIntegration.inventory_data[inventory_id]

            for ingredient in recipe.ingredients:
                if (
                    ingredient.item_id in inventory
                    and inventory[ingredient.item_id] >= ingredient.quantity
                ):
                    inventory[ingredient.item_id] -= ingredient.quantity
                else:
                    # Use substitution if available
                    for group, subs in ingredient.substitution_groups.items():
                        for sub_item, sub_qty in subs.items():
                            if sub_item in inventory and inventory[sub_item] >= sub_qty:
                                inventory[sub_item] -= sub_qty
                                break

        # Mock _process_results to add crafted items to inventory
        def mock_process_results(self, results, inventory_id):
            inventory = TestCraftingIntegration.inventory_data[inventory_id]

            for result in results:
                item_id = result["item_id"]
                quantity = result["quantity"]

                if item_id in inventory:
                    inventory[item_id] += quantity
                else:
                    inventory[item_id] = quantity

        # Apply the mocks to CraftingService
        TestCraftingIntegration.inventory_data = self.inventory_data
        CraftingService._validate_inventory = mock_validate_inventory
        CraftingService._process_ingredients = mock_process_ingredients
        CraftingService._process_results = mock_process_results

    def test_integration_workflow(self):
        """Test the complete crafting workflow."""
        character_id = "character1"
        inventory_id = "character1_inventory"
        skills = {"smithing": 5, "leatherworking": 3}

        # Step 1: Learn recipes
        learn_result, _ = learn_recipe(character_id, "iron_sword")
        self.assertTrue(learn_result)

        learn_result, _ = learn_recipe(character_id, "leather_armor")
        self.assertTrue(learn_result)

        # Step 2: Get available recipes
        available_recipes = get_available_recipes(character_id, skills)
        self.assertEqual(len(available_recipes), 2)
        self.assertIn("iron_sword", available_recipes)
        self.assertIn("leather_armor", available_recipes)

        # Step 3: Check if we can craft a recipe
        can_craft_result, _ = can_craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills=skills,
        )
        self.assertTrue(can_craft_result)

        # Step 4: Craft the item
        initial_iron_ingot = self.inventory_data[inventory_id]["iron_ingot"]
        initial_leather_strip = self.inventory_data[inventory_id]["leather_strip"]

        result = craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills=skills,
        )

        # Verify crafting was successful
        self.assertTrue(result["success"])
        self.assertEqual(len(result["results"]), 1)
        self.assertEqual(result["results"][0]["item_id"], "iron_sword")

        # Verify ingredients were consumed
        self.assertEqual(
            self.inventory_data[inventory_id]["iron_ingot"], initial_iron_ingot - 3
        )
        self.assertEqual(
            self.inventory_data[inventory_id]["leather_strip"],
            initial_leather_strip - 2,
        )

        # Verify result was added to inventory
        self.assertIn("iron_sword", self.inventory_data[inventory_id])
        self.assertEqual(self.inventory_data[inventory_id]["iron_sword"], 1)

        # Step 5: Try crafting with substitutions
        # Reset inventory for this test
        self.inventory_data[inventory_id]["iron_ingot"] = 0  # No iron ingots
        self.inventory_data[inventory_id]["scrap_metal"] = 10  # But we have scrap metal

        result = craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills=skills,
        )

        # Verify crafting was successful with substitution
        self.assertTrue(result["success"])
        self.assertEqual(
            self.inventory_data[inventory_id]["scrap_metal"], 5
        )  # 10 - 5 = 5
        self.assertEqual(
            self.inventory_data[inventory_id]["iron_sword"], 2
        )  # Now we have 2

    def test_integration_discovery(self):
        """Test the recipe discovery workflow."""
        character_id = "character1"

        # Initially, we don't have any recipes
        available_recipes = get_available_recipes(character_id)
        self.assertEqual(len(available_recipes), 0)

        # Discover a recipe
        with patch("random.choice", return_value="iron_sword"):
            result, _, recipe_id = discover_recipe(
                character_id=character_id,
                discovery_method="smith_mentor",
                context_data={"location": "blacksmith_shop"},
            )

            self.assertTrue(result)
            self.assertEqual(recipe_id, "iron_sword")

        # Now we should have the recipe
        available_recipes = get_available_recipes(character_id)
        self.assertEqual(len(available_recipes), 1)
        self.assertIn("iron_sword", available_recipes)

        # Try to craft the discovered recipe
        can_craft_result, _ = can_craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id="character1_inventory",
            station_id="basic_smithy",
            skills={"smithing": 5},
        )
        self.assertTrue(can_craft_result)

    def test_integration_failure_cases(self):
        """Test failure cases in the crafting workflow."""
        character_id = "character1"
        inventory_id = "character1_inventory"

        # Learn the recipe
        learn_recipe(character_id, "iron_sword")

        # Test case 1: Missing skill
        can_craft_result, reason = can_craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills={"smithing": 1},  # Not enough skill level
        )
        self.assertFalse(can_craft_result)
        self.assertIn("skill", reason.lower())

        # Test case 2: Missing station
        can_craft_result, reason = can_craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id=None,  # No station provided
            skills={"smithing": 5},
        )
        self.assertFalse(can_craft_result)
        self.assertIn("station", reason.lower())

        # Test case 3: Missing ingredients
        # Empty the inventory
        self.inventory_data[inventory_id]["iron_ingot"] = 0
        self.inventory_data[inventory_id]["scrap_metal"] = 0

        can_craft_result, reason = can_craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills={"smithing": 5},
        )
        self.assertFalse(can_craft_result)
        self.assertIn("ingredient", reason.lower())

        # Test case 4: Craft attempt with missing ingredients
        result = craft(
            character_id=character_id,
            recipe_id="iron_sword",
            inventory_id=inventory_id,
            station_id="basic_smithy",
            skills={"smithing": 5},
        )

        self.assertFalse(result["success"])
        self.assertIn("ingredient", result["message"].lower())


if __name__ == "__main__":
    unittest.main()
