"""
Tests for backend.systems.crafting.schemas

Comprehensive test suite for all crafting schema modules.
"""

import unittest
from unittest.mock import Mock, patch
import pytest
from pydantic import ValidationError

from backend.systems.crafting.schemas.ingredient_schema import IngredientSchema
from backend.systems.crafting.schemas.recipe_schema import RecipeSchema
from backend.systems.crafting.schemas.result_schema import ResultSchema  
from backend.systems.crafting.schemas.station_schema import StationSchema


class TestIngredientSchema(unittest.TestCase):
    """Test class for IngredientSchema"""
    
    def setUp(self):
        """Set up test fixtures."""
        self.valid_ingredient_data = {
            "item_id": "iron_ingot",
            "quantity": 5,
            "is_consumed": True,
            "substitution_groups": {
                "metals": {
                    "steel_ingot": 3,
                    "copper_ingot": 7
                }
            }
        }
        
        self.minimal_ingredient_data = {
            "item_id": "wood",
            "quantity": 1
        }

    def test_serialize_valid_ingredient(self):
        """Test creating a valid ingredient."""
        ingredient = IngredientSchema(**self.valid_ingredient_data)
        
        self.assertEqual(ingredient.item_id, "iron_ingot")
        self.assertEqual(ingredient.quantity, 5)
        self.assertEqual(ingredient.is_consumed, True)
        self.assertIsNotNone(ingredient.substitution_groups)

    def test_deserialize_valid_ingredient(self):
        """Test creating valid ingredient from data."""
        ingredient = IngredientSchema(**self.valid_ingredient_data)
        
        self.assertEqual(ingredient.item_id, "iron_ingot")
        self.assertEqual(ingredient.quantity, 5)
        self.assertEqual(ingredient.is_consumed, True)

    def test_deserialize_minimal_ingredient(self):
        """Test creating minimal ingredient from data."""
        ingredient = IngredientSchema(**self.minimal_ingredient_data)
        
        self.assertEqual(ingredient.item_id, "wood")
        self.assertEqual(ingredient.quantity, 1)
        # Should have defaults
        self.assertEqual(ingredient.is_consumed, True)

    def test_invalid_item_id(self):
        """Test validation error for missing item_id."""
        invalid_data = {
            "quantity": 5
        }
        
        with self.assertRaises(ValidationError):
            IngredientSchema(**invalid_data)

    def test_invalid_quantity(self):
        """Test validation error for invalid quantity."""
        invalid_data = {
            "item_id": "wood",
            "quantity": -1  # Negative quantity
        }
        
        with self.assertRaises(ValidationError):
            IngredientSchema(**invalid_data)

    def test_invalid_quantity_type(self):
        """Test validation error for wrong quantity type."""
        invalid_data = {
            "item_id": "wood",
            "quantity": "five"  # String instead of int
        }
        
        with self.assertRaises(ValidationError):
            IngredientSchema(**invalid_data)


class TestResultSchema(unittest.TestCase):
    """Test class for ResultSchema"""
    
    def setUp(self):
        """Set up test fixtures."""
        self.valid_result_data = {
            "item_id": "iron_sword",
            "quantity": 1,
            "probability": 0.85,
            "metadata": {
                "quality": "normal",
                "durability": 100
            }
        }
        
        self.minimal_result_data = {
            "item_id": "wooden_stick",
            "quantity": 1
        }

    def test_serialize_valid_result(self):
        """Test creating a valid result."""
        result = ResultSchema(**self.valid_result_data)
        
        self.assertEqual(result.item_id, "iron_sword")
        self.assertEqual(result.quantity, 1)
        self.assertEqual(result.probability, 0.85)
        self.assertIsNotNone(result.metadata)

    def test_deserialize_valid_result(self):
        """Test creating valid result data."""
        result = ResultSchema(**self.valid_result_data)
        
        self.assertEqual(result.item_id, "iron_sword")
        self.assertEqual(result.quantity, 1)
        self.assertEqual(result.probability, 0.85)

    def test_deserialize_minimal_result(self):
        """Test creating minimal result data."""
        result = ResultSchema(**self.minimal_result_data)
        
        self.assertEqual(result.item_id, "wooden_stick")
        self.assertEqual(result.quantity, 1)
        # Should have defaults for probability
        self.assertIsNotNone(result.probability)

    def test_invalid_item_id(self):
        """Test validation error for missing item_id."""
        invalid_data = {
            "quantity": 1
        }
        
        with self.assertRaises(ValidationError):
            ResultSchema(**invalid_data)

    def test_invalid_probability(self):
        """Test validation error for invalid probability."""
        invalid_data = {
            "item_id": "iron_sword",
            "quantity": 1,
            "probability": 1.5  # Greater than 1.0
        }
        
        with self.assertRaises(ValidationError):
            ResultSchema(**invalid_data)

    def test_negative_probability(self):
        """Test validation error for negative probability."""
        invalid_data = {
            "item_id": "iron_sword",
            "quantity": 1,
            "probability": -0.1
        }
        
        with self.assertRaises(ValidationError):
            ResultSchema(**invalid_data)

    def test_zero_quantity(self):
        """Test validation error for zero quantity."""
        invalid_data = {
            "item_id": "iron_sword",
            "quantity": 0
        }
        
        with self.assertRaises(ValidationError):
            ResultSchema(**invalid_data)


class TestStationSchema(unittest.TestCase):
    """Test class for StationSchema"""
    
    def setUp(self):
        """Set up test fixtures."""
        self.valid_station_data = {
            "name": "Advanced Smithy",
            "description": "An advanced forge for metalworking",
            "station_type": "smithy",
            "level": 3,
            "metadata": {
                "required_space": 8,
                "power_required": 50,
                "build_materials": {
                    "stone": 20,
                    "iron": 15,
                    "wood": 30
                }
            }
        }
        
        self.minimal_station_data = {
            "name": "Basic Forge",
            "station_type": "smithy"
        }

    def test_serialize_valid_station(self):
        """Test creating a valid station."""
        result = StationSchema(**self.valid_station_data)
        
        self.assertEqual(result.name, "Advanced Smithy")
        self.assertEqual(result.station_type, "smithy")
        self.assertEqual(result.level, 3)
        self.assertIsNotNone(result.metadata)

    def test_deserialize_valid_station(self):
        """Test creating valid station data."""
        result = StationSchema(**self.valid_station_data)
        
        self.assertEqual(result.name, "Advanced Smithy")
        self.assertEqual(result.station_type, "smithy")
        self.assertEqual(result.level, 3)

    def test_deserialize_minimal_station(self):
        """Test creating minimal station data."""
        result = StationSchema(**self.minimal_station_data)
        
        self.assertEqual(result.name, "Basic Forge")
        self.assertEqual(result.station_type, "smithy")
        # Should have defaults
        self.assertIsNotNone(result.level)
        self.assertIsNotNone(result.description)

    def test_invalid_station_name(self):
        """Test validation error for missing station name."""
        invalid_data = {
            "station_type": "workshop"
        }
        
        with self.assertRaises(ValidationError):
            StationSchema(**invalid_data)

    def test_station_with_defaults(self):
        """Test that station works with defaults."""
        minimal_data = {
            "name": "Test Station"
        }
        
        result = StationSchema(**minimal_data)
        self.assertEqual(result.name, "Test Station")
        # station_type has default of "basic"
        self.assertEqual(result.station_type, "basic")

    def test_negative_level(self):
        """Test validation error for negative level."""
        invalid_data = {
            "name": "Test Station",
            "station_type": "workshop",
            "level": -1
        }
        
        with self.assertRaises(ValidationError):
            StationSchema(**invalid_data)


class TestRecipeSchema(unittest.TestCase):
    """Test class for RecipeSchema"""
    
    def setUp(self):
        """Set up test fixtures."""
        self.valid_recipe_data = {
            "name": "Iron Sword",
            "description": "A sturdy iron sword",
            "skill_required": "smithing",
            "min_skill_level": 15,
            "station_required": "smithy",
            "station_level": 2,
            "ingredients": [
                {
                    "item_id": "iron_ingot",
                    "quantity": 3,
                    "is_consumed": True
                },
                {
                    "item_id": "wood_handle",
                    "quantity": 1,
                    "is_consumed": True
                }
            ],
            "results": [
                {
                    "item_id": "iron_sword",
                    "quantity": 1,
                    "probability": 0.9
                }
            ],
            "is_hidden": False,
            "is_enabled": True,
            "metadata": {
                "category": "weapons",
                "difficulty": "intermediate",
                "crafting_time": 300
            }
        }
        
        self.minimal_recipe_data = {
            "name": "Wooden Stick",
            "ingredients": [
                {
                    "item_id": "wood",
                    "quantity": 1
                }
            ],
            "results": [
                {
                    "item_id": "wooden_stick",
                    "quantity": 1
                }
            ]
        }

    def test_serialize_valid_recipe(self):
        """Test creating a valid recipe."""
        result = RecipeSchema(**self.valid_recipe_data)
        
        self.assertEqual(result.name, "Iron Sword")
        self.assertEqual(result.skill_required, "smithing")
        self.assertEqual(result.min_skill_level, 15)
        self.assertIsNotNone(result.ingredients)
        self.assertIsNotNone(result.results)

    def test_deserialize_valid_recipe(self):
        """Test creating valid recipe data."""
        result = RecipeSchema(**self.valid_recipe_data)
        
        self.assertEqual(result.name, "Iron Sword")
        self.assertEqual(result.skill_required, "smithing")
        self.assertEqual(result.min_skill_level, 15)
        self.assertIsInstance(result.ingredients, list)
        self.assertIsInstance(result.results, list)

    def test_deserialize_minimal_recipe(self):
        """Test creating minimal recipe data."""
        result = RecipeSchema(**self.minimal_recipe_data)
        
        self.assertEqual(result.name, "Wooden Stick")
        self.assertIsInstance(result.ingredients, list)
        self.assertIsInstance(result.results, list)
        # Should have defaults
        self.assertIsNotNone(result.is_hidden)
        self.assertIsNotNone(result.is_enabled)

    def test_invalid_recipe_name(self):
        """Test validation error for missing recipe name."""
        invalid_data = {
            "ingredients": [{"item_id": "wood", "quantity": 1}],
            "results": [{"item_id": "stick", "quantity": 1}]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_missing_ingredients(self):
        """Test validation error for missing ingredients."""
        invalid_data = {
            "name": "Test Recipe",
            "results": [{"item_id": "stick", "quantity": 1}]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_recipe_with_defaults(self):
        """Test that recipe works with default empty results."""
        minimal_data = {
            "name": "Test Recipe",
            "ingredients": [{"item_id": "wood", "quantity": 1}]
            # results is optional with default empty list
        }
        
        result = RecipeSchema(**minimal_data)
        self.assertEqual(result.name, "Test Recipe")
        self.assertIsInstance(result.results, list)
        self.assertEqual(len(result.results), 0)  # Empty by default

    def test_recipe_without_ingredients_fails(self):
        """Test validation error for missing ingredients (required field)."""
        invalid_data = {
            "name": "Test Recipe"
            # ingredients is required
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_empty_ingredients_list_fails(self):
        """Test validation error for empty ingredients list.""" 
        # Note: This might actually be allowed by the schema
        # Let's test what happens
        test_data = {
            "name": "Test Recipe",
            "ingredients": [],  # Empty list
            "results": [{"item_id": "test", "quantity": 1}]
        }
        
        # If this doesn't raise an error, the schema allows empty ingredients
        try:
            result = RecipeSchema(**test_data)
            # If we get here, empty ingredients are allowed
            self.assertEqual(result.name, "Test Recipe")
            self.assertIsInstance(result.ingredients, list)
            self.assertEqual(len(result.ingredients), 0)
        except ValidationError:
            # If validation error occurs, empty ingredients are not allowed
            pass

    def test_invalid_skill_level(self):
        """Test validation error for negative skill level."""
        invalid_data = {
            "name": "Test Recipe",
            "min_skill_level": -1,  # Negative skill level
            "ingredients": [{"item_id": "test", "quantity": 1}],
            "results": [{"item_id": "test", "quantity": 1}]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_invalid_station_level(self):
        """Test validation error for negative station level."""
        invalid_data = {
            "name": "Test Recipe",
            "station_level": -1,  # Negative station level
            "ingredients": [{"item_id": "test", "quantity": 1}],
            "results": [{"item_id": "test", "quantity": 1}]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_nested_ingredient_validation(self):
        """Test that nested ingredient validation works."""
        invalid_data = {
            "name": "Test Recipe",
            "ingredients": [
                {
                    "item_id": "iron",
                    "quantity": -1  # Invalid negative quantity
                }
            ],
            "results": [{"item_id": "test", "quantity": 1}]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)

    def test_nested_result_validation(self):
        """Test that nested result validation works."""
        invalid_data = {
            "name": "Test Recipe",
            "ingredients": [{"item_id": "iron", "quantity": 1}],
            "results": [
                {
                    "item_id": "test",
                    "quantity": 0  # Invalid zero quantity
                }
            ]
        }
        
        with self.assertRaises(ValidationError):
            RecipeSchema(**invalid_data)


def test_schema_module_imports():
    """Test that all schema modules can be imported without errors."""
    from backend.systems.crafting.schemas import ingredient_schema
    from backend.systems.crafting.schemas import recipe_schema
    from backend.systems.crafting.schemas import result_schema
    from backend.systems.crafting.schemas import station_schema
    
    assert ingredient_schema is not None
    assert recipe_schema is not None
    assert result_schema is not None
    assert station_schema is not None


if __name__ == "__main__":
    unittest.main() 