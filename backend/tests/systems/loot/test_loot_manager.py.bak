"""
Tests for the LootManager class that follows the Development Bible architecture.

This module contains tests for the LootManager singleton that oversees all loot-related operations.
"""

import unittest
from unittest.mock import patch, MagicMock, call
import copy
import json
from datetime import datetime

from backend.systems.loot.loot_manager import LootManager
from backend.systems.events.event_dispatcher import EventDispatcher
from backend.systems.loot.loot_events import (
    LootGeneratedEvent,
    ItemIdentificationEvent,
    ItemEnhancementEvent,
    ShopInventoryEvent,
    ShopRestockEvent,
    ShopTransactionEvent,
    LootAnalyticsEvent,
)


class TestLootManager(unittest.TestCase):
    """Test cases for the LootManager singleton."""

    def setUp(self):
        """Set up test fixtures before each test."""
        # Create a clean test instance with mocks
        with patch(
            "backend.systems.loot.loot_manager.EventDispatcher"
        ) as mock_event_dispatcher:
            # Reset the singleton state
            LootManager._instance = None
            self.mock_event_dispatcher = MagicMock()
            mock_event_dispatcher.get_instance.return_value = self.mock_event_dispatcher

            # Mock equipment data for initialization
            self.equipment_pool = {
                "armor": [
                    {
                        "id": "a1",
                        "name": "Leather Armor",
                        "category": "armor",
                        "rarity": "common",
                        "value": 10,
                    }
                ],
                "weapon": [
                    {
                        "id": "w1",
                        "name": "Sword",
                        "category": "weapon",
                        "rarity": "common",
                        "value": 15,
                    }
                ],
                "gear": [
                    {
                        "id": "g1",
                        "name": "Backpack",
                        "category": "gear",
                        "rarity": "common",
                        "value": 5,
                    }
                ],
            }

            self.item_effects = [
                {
                    "id": "e1",
                    "name": "Fire Damage",
                    "type": "damage",
                    "element": "fire",
                },
                {
                    "id": "e2",
                    "name": "Frost Resistance",
                    "type": "resistance",
                    "element": "frost",
                },
            ]

            self.monster_feats = [
                {"id": "m1", "name": "Poison Bite", "type": "poison"},
                {"id": "m2", "name": "Fire Breath", "type": "fire"},
            ]

            # Create and initialize the loot manager
            self.loot_manager = LootManager.get_instance()
            self.loot_manager.initialize(
                equipment_pool=self.equipment_pool,
                item_effects=self.item_effects,
                monster_feats=self.monster_feats,
            )

    def test_singleton_pattern(self):
        """Test that the LootManager follows the singleton pattern."""
        # Getting the instance twice should return the same object
        manager1 = LootManager.get_instance()
        manager2 = LootManager.get_instance()
        self.assertIs(manager1, manager2)

        # Direct instantiation should raise an error
        with self.assertRaises(RuntimeError):
            LootManager()

    def test_initialize(self):
        """Test initializing the LootManager with required data."""
        # Check that data was properly initialized
        self.assertEqual(self.loot_manager._equipment_pool, self.equipment_pool)
        self.assertEqual(self.loot_manager._item_effects, self.item_effects)
        self.assertEqual(self.loot_manager._monster_feats, self.monster_feats)

    @patch("backend.systems.loot.loot_manager.generate_loot_bundle")
    def test_generate_loot(self, mock_generate_loot_bundle):
        """Test generating loot and emitting appropriate events."""
        # Mock return value for generate_loot_bundle
        mock_loot = {
            "gold": 100,
            "items": [
                {
                    "id": "item1",
                    "name": "Magic Sword",
                    "rarity": "uncommon",
                    "is_quest_item": False,
                },
                {
                    "id": "item2",
                    "name": "Health Potion",
                    "rarity": "common",
                    "is_quest_item": False,
                },
            ],
            "rarity_level": "uncommon",
        }
        mock_generate_loot_bundle.return_value = mock_loot

        # Call the method
        monster_levels = [3, 4, 3]
        location_id = 42
        region_id = 7
        result = self.loot_manager.generate_loot(
            monster_levels=monster_levels,
            location_id=location_id,
            region_id=region_id,
            source_type="combat",
        )

        # Check the result
        self.assertEqual(result, mock_loot)

        # Verify generate_loot_bundle was called with expected arguments
        mock_generate_loot_bundle.assert_called_once_with(
            monster_levels=monster_levels,
            equipment_pool=self.equipment_pool,
            item_effects=self.item_effects,
            monster_feats=self.monster_feats,
            source_type="combat",
            location_id=location_id,
            region_id=region_id,
        )

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the first call args
        args, _ = self.mock_event_dispatcher.publish.call_args_list[0]
        event = args[0]
        self.assertIsInstance(event, LootGeneratedEvent)
        self.assertEqual(event.monster_levels, monster_levels)
        self.assertEqual(event.gold_amount, 100)
        self.assertEqual(event.item_count, 2)
        self.assertEqual(event.has_magical_item, True)  # uncommon item
        self.assertEqual(event.has_quest_item, False)
        self.assertEqual(event.location_id, location_id)
        self.assertEqual(event.region_id, region_id)
        self.assertEqual(event.source_type, "combat")

    @patch("backend.systems.loot.loot_manager.generate_location_specific_loot")
    def test_generate_location_loot(self, mock_generate_location_loot):
        """Test generating location-specific loot and emitting appropriate events."""
        # Mock return value
        mock_loot = {
            "gold": 50,
            "items": [
                {
                    "id": "item3",
                    "name": "Ancient Scroll",
                    "rarity": "rare",
                    "is_quest_item": True,
                },
                {
                    "id": "item4",
                    "name": "Gemstone",
                    "rarity": "uncommon",
                    "is_quest_item": False,
                },
            ],
            "rarity_level": "rare",
        }
        mock_generate_location_loot.return_value = mock_loot

        # Call the method
        location_id = 42
        location_type = "dungeon"
        biome_type = "forest"
        faction_id = 3
        region_id = 7
        result = self.loot_manager.generate_location_loot(
            location_id=location_id,
            location_type=location_type,
            biome_type=biome_type,
            faction_id=faction_id,
            region_id=region_id,
        )

        # Check the result
        self.assertEqual(result, mock_loot)

        # Verify function was called with expected arguments
        mock_generate_location_loot.assert_called_once_with(
            location_id=location_id,
            location_type=location_type,
            biome_type=biome_type,
            faction_id=faction_id,
            faction_type=None,
            motif=None,
            monster_levels=None,
            equipment_pool=self.equipment_pool,
            item_effects=self.item_effects,
            monster_feats=self.monster_feats,
        )

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Find the LootGeneratedEvent in call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if (
                isinstance(event, LootGeneratedEvent)
                and event.event_type == "loot.location_generated"
            ):
                self.assertEqual(event.gold_amount, 50)
                self.assertEqual(event.item_count, 2)
                self.assertEqual(event.has_magical_item, True)
                self.assertEqual(event.has_quest_item, True)
                self.assertEqual(event.location_id, location_id)
                self.assertEqual(event.region_id, region_id)
                self.assertEqual(event.source_type, "location")
                break
        else:
            self.fail("Location loot generation event was not published")

    def test_identify_item(self):
        """Test item identification and event emission."""
        # Setup mock item and identification result
        item = {
            "id": "item1",
            "name": "Unknown Sword",
            "rarity": "rare",
            "effects": [{"id": "e1", "name": "Fire Damage", "discovered": False}],
            "identification_level": 0,
        }

        # Identified item with discovered effect
        identified_item = copy.deepcopy(item)
        identified_item["identification_level"] = 1
        identified_item["effects"][0]["discovered"] = True

        # Call the method with force_identify=True to ensure success
        result_item, success, discovered = self.loot_manager.identify_item(
            item=item,
            character_id=123,
            skill_level=5,
            use_tome=False,
            tome_bonus=0,
            force_identify=True,  # Force success for deterministic test
        )

        # Check results
        self.assertTrue(success)
        self.assertEqual(result_item["name_revealed"], True)
        self.assertEqual(len(discovered), 1)  # Should discover one effect

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ItemIdentificationEvent):
                self.assertEqual(event.item_id, "item1")
                self.assertEqual(event.character_id, 123)
                self.assertEqual(event.success, True)
                self.assertEqual(len(event.discovered_effects), 1)
                break
        else:
            self.fail("ItemIdentificationEvent was not published")

    def test_enhance_item(self):
        """Test item enhancement and event emission."""
        # Setup mock item and enhancement result
        item = {"id": "item1", "name": "Sword", "rarity": "common", "value": 10}

        # Enhanced item with higher rarity
        enhanced_item = copy.deepcopy(item)
        enhanced_item["rarity"] = "uncommon"
        enhanced_item["value"] = 20

        # Call the method with force_success=True to ensure success
        result_item, success, message = self.loot_manager.enhance_item(
            item=item,
            character_id=123,
            target_level=2,
            craft_skill_used="smithing",
            character_craft_skill=15,  # High skill to ensure success
            tool_quality=5,
            material_quality=5,
            special_ingredients=["dragon_scale"],
            force_success=True,  # Force success for deterministic test
        )

        # Check results
        self.assertTrue(success)
        self.assertEqual(result_item["level"], 2)  # Level should be upgraded

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ItemEnhancementEvent):
                self.assertEqual(event.item_id, "item1")
                self.assertEqual(
                    event.item_name, "Sword"
                )  # Should use the "name" field
                self.assertEqual(event.character_id, 123)
                self.assertEqual(event.success, True)
                break
        else:
            self.fail("ItemEnhancementEvent was not published")

    @patch("backend.systems.loot.loot_manager.generate_shop_inventory")
    def test_generate_shop_inventory(self, mock_generate_shop_inventory):
        """Test generating shop inventory and event emission."""
        # Mock shop inventory
        mock_inventory = [
            {"id": "item1", "name": "Sword", "rarity": "common", "price": 10},
            {"id": "item2", "name": "Shield", "rarity": "common", "price": 8},
        ]
        mock_generate_shop_inventory.return_value = mock_inventory

        # Call the method
        result = self.loot_manager.generate_shop_inventory(
            shop_id=5,
            shop_type="weapons",
            shop_tier=2,
            region_id=7,
            faction_id=3,
            restocking=False,
            count=10,
        )

        # Check results
        self.assertEqual(result, mock_inventory)

        # Verify generate_shop_inventory was called with expected arguments
        mock_generate_shop_inventory.assert_called_once_with(
            shop_id=5,
            shop_type="weapons",
            shop_tier=2,
            region_id=7,
            faction_id=3,
            restocking=False,
            count=10,
        )

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ShopInventoryEvent):
                self.assertEqual(event.shop_id, 5)
                self.assertEqual(event.shop_type, "weapons")
                self.assertEqual(event.shop_tier, 2)
                self.assertEqual(event.region_id, 7)
                self.assertEqual(event.faction_id, 3)
                self.assertEqual(event.item_count, 2)
                self.assertEqual(event.restocking, False)
                break
        else:
            self.fail("ShopInventoryEvent was not published")

    @patch("backend.systems.loot.loot_manager.restock_shop_inventory")
    def test_restock_shop(self, mock_restock_function):
        """Test shop restocking and event emission."""
        # Mock current inventory and restock result
        current_inventory = [
            {"id": "item1", "name": "Sword", "rarity": "common", "price": 10},
            {"id": "item2", "name": "Shield", "rarity": "common", "price": 8},
        ]

        restocked_inventory = current_inventory + [
            {"id": "item3", "name": "Potion", "rarity": "common", "price": 5}
        ]

        # Mock the restock function
        mock_restock_function.return_value = restocked_inventory

        # Call the method
        result = self.loot_manager.restock_shop(
            shop_id=5,
            current_inventory=current_inventory,
            shop_type="general",
            shop_tier=2,
            region_id=7,
            faction_id=3,
            max_items=20,
        )

        # Check results
        self.assertEqual(result, restocked_inventory)

        # Verify restock_shop_inventory was called with expected arguments
        mock_restock_function.assert_called_once_with(
            shop_id=5,
            current_inventory=current_inventory,
            shop_type="general",
            shop_tier=2,
            region_id=7,
            faction_id=3,
            max_items=20,
        )

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ShopRestockEvent):
                self.assertEqual(event.shop_id, 5)
                self.assertEqual(event.shop_type, "general")
                self.assertEqual(event.shop_tier, 2)
                self.assertEqual(event.region_id, 7)
                # Note: ShopRestockEvent doesn't have faction_id field
                self.assertEqual(event.new_item_count, 1)  # Added 1 new item
                break
        else:
            self.fail("ShopRestockEvent was not published")

    @patch("backend.systems.loot.loot_manager.purchase_item_from_shop")
    @patch("backend.systems.loot.loot_manager.sell_item_to_shop")
    def test_process_shop_transaction_purchase(self, mock_sell, mock_purchase):
        """Test shop purchase transaction and event emission."""
        # Mock inventory and purchase result
        shop_inventory = [
            {"id": "item1", "name": "Sword", "rarity": "common", "price": 10},
            {"id": "item2", "name": "Shield", "rarity": "common", "price": 8},
        ]

        # Mock purchase result: (transaction_result, price_paid, updated_inventory)
        mock_purchase.return_value = (
            {"success": True, "message": "Purchase successful", "gold_spent": 10},
            10,
            [{"id": "item2", "name": "Shield", "rarity": "common", "price": 8}],
        )

        # Call the method for purchase
        result = self.loot_manager.process_shop_transaction(
            shop_id=5,
            character_id=123,
            item_id="item1",
            shop_inventory=shop_inventory,
            shop_type="weapons",
            shop_tier=2,
            quantity=1,
            is_purchase=True,
            location_id=42,
            region_id=7,
        )

        # Check results
        self.assertEqual(result["success"], True)
        self.assertEqual(result["gold_amount"], 10)

        # Verify purchase_item_from_shop was called with expected arguments
        mock_purchase.assert_called_once()
        mock_sell.assert_not_called()

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ShopTransactionEvent):
                self.assertEqual(event.shop_id, 5)
                self.assertEqual(event.character_id, 123)
                self.assertEqual(event.item_id, "item1")
                self.assertEqual(event.quantity, 1)
                self.assertEqual(event.gold_amount, 10)
                self.assertEqual(event.transaction_type, "purchase")
                self.assertEqual(event.success, True)
                break
        else:
            self.fail("ShopTransactionEvent was not published")

    @patch("backend.systems.loot.loot_manager.purchase_item_from_shop")
    @patch("backend.systems.loot.loot_manager.sell_item_to_shop")
    def test_process_shop_transaction_sell(self, mock_sell, mock_purchase):
        """Test shop sell transaction and event emission."""
        # Mock inventory and sell result
        shop_inventory = [
            {"id": "item1", "name": "Sword", "rarity": "common", "price": 10},
            {"id": "item2", "name": "Shield", "rarity": "common", "price": 8},
        ]

        # Mock sell result: just return the gold amount
        mock_sell.return_value = 5

        # Add the item to be sold to the shop inventory for this test
        shop_inventory_with_item = shop_inventory + [
            {"id": "item3", "name": "Dagger", "rarity": "common", "price": 5}
        ]

        # Call the method for selling
        result = self.loot_manager.process_shop_transaction(
            shop_id=5,
            character_id=123,
            item_id="item3",
            shop_inventory=shop_inventory_with_item,
            shop_type="weapons",
            shop_tier=2,
            quantity=1,
            is_purchase=False,
            location_id=42,
            region_id=7,
        )

        # Check results
        self.assertEqual(result["transaction_type"], "sale")
        self.assertEqual(result["gold_amount"], 5)

        # Verify sell_item_to_shop was called with expected arguments
        mock_sell.assert_called_once()
        mock_purchase.assert_not_called()

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, ShopTransactionEvent):
                self.assertEqual(event.shop_id, 5)
                self.assertEqual(event.character_id, 123)
                self.assertEqual(event.item_id, "item3")
                self.assertEqual(event.quantity, 1)
                self.assertEqual(event.gold_amount, 5)
                self.assertEqual(event.transaction_type, "sale")
                self.assertEqual(event.success, True)
                break
        else:
            self.fail("ShopTransactionEvent was not published")

    def test_track_analytics(self):
        """Test analytics tracking through event emission."""
        # Call the method
        self.loot_manager.track_analytics(
            event_category="loot_generation",
            event_action="generated",
            item_id="test_item_123",
            item_name="Test Item",
            item_rarity="rare",
            character_id=456,
            value=100.0,
            metadata={"location": "dungeon", "monster_level": 5},
        )

        # Verify event was published with expected data
        self.mock_event_dispatcher.publish.assert_called()
        # Get the event from the call args
        for call_args in self.mock_event_dispatcher.publish.call_args_list:
            args, _ = call_args
            event = args[0]
            if isinstance(event, LootAnalyticsEvent):
                self.assertEqual(event.event_category, "loot_generation")
                self.assertEqual(event.event_action, "generated")
                self.assertEqual(event.item_id, "test_item_123")
                self.assertEqual(event.item_name, "Test Item")
                self.assertEqual(event.item_rarity, "rare")
                self.assertEqual(event.character_id, 456)
                self.assertEqual(event.value, 100.0)
                self.assertEqual(event.metadata["location"], "dungeon")
                self.assertEqual(event.metadata["monster_level"], 5)
                break
        else:
            self.fail("LootAnalyticsEvent was not published")


if __name__ == "__main__":
    unittest.main()
